---
title: "Mental Health Data Analysis"
author: "Name:莊明儒 &nbsp; Student ID:111024513"
header-includes:
- \usepackage{xeCJK}
- \setCJKmainfont{標楷體}
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{makecell}
- \usepackage{xcolor}
- \usepackage{float}
output:
  bookdown::pdf_document2:
    latex_engine: xelatex
    toc: no
---

```{r setup, include=FALSE}
options(knitr.kable.NA = '')
knitr::opts_chunk$set(echo = FALSE, fig.height = 10, fig.width = 16, fig.align = "center")

library(MASS)
library(abind)
library(Matrix)

library(tidyverse)
library(kableExtra)

library(numDeriv)
library(sandwich)

library(ggplot2)
library(ggpubr)

library(pracma)
library(foreach)
library(doParallel)
library(doSNOW)
```

# Read data

```{r}
source("Wang2014_12.r")
source("Han2018_2.r")
source("KimYu2012.r")
source("ZhaoMa2022_2.r")
source("ChuangChao2023_SM.r")
```

```{r}
dat.app = read.csv("data_application.csv")
percent = dat.app$Percentage
class.n = round(2486*percent/100)

dat = matrix(NA, 2486, 5)
for(i in 1:nrow(dat.app)){
  dat[((sum(class.n[0:(i-1)]))+1):sum(class.n[1:i]),] = matrix(rep(unlist(dat.app[i,]), each = class.n[i]), class.n[i], 5)
}
dat = as.data.frame(dat[, -5])

dat[dat == "Yes"] = 1
dat[dat == "No"] = 0
dat[dat == "Abnormal"] = 1
dat[dat == "Normal"] = 0
dat[dat == "Missing"] = NA
colnames(dat) = c("father", "health", "y", "parent_report")
dat$r = ifelse(is.na(dat$y), 0, 1)
dat$father = as.numeric(dat$father)
dat$health = as.numeric(dat$health)
dat$y = as.numeric(dat$y)
dat$parent_report = as.numeric(dat$parent_report)

dat$y[dat$r == 0] = -1
original.dat = dat

dim(dat)
summary(dat)
apply(dat, 2, function(v) sum(!is.na(v)))
apply(dat, 2, function(v) sum(is.na(v))/length(v))
```

# Data description:

# Some primary analysis:

```{r}
N = nrow(dat)
n = sum(dat$r)
mu.complete = mean(dat$y[dat$r == 1])
se.complete = sd(dat$y[dat$r == 1])/sqrt(n)
```

```{r}
outcome.fit = glm(y~I(-father)+health+parent_report, family = "binomial", dat, subset = r == 1)
summary(outcome.fit)
```

```{r}
pi.fit = glm(r~health+father, family = "binomial", dat)
summary(pi.fit)
```

# Analysis with our proposed methods

```{r}
family = "binomial"
```

```{r}
bootstrap = function(propensity.list, auxilliary.f, dat, family, B){
  source("Wang2014_12.r", local = TRUE)
  source("Han2018_2.r", local = TRUE)
  source("KimYu2012.r", local = TRUE)
  source("ChuangChao2023_SM.r", local = TRUE)
  
  N = nrow(dat)
  original.dat = dat
  
  cores = detectCores()
  cl = makeCluster(cores - 2) ## number of clusters 
  registerDoSNOW(cl)
  
  pb = txtProgressBar(max = B, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts = list(progress = progress)
  parallel_packages = c("pracma", "tidyverse", "Matrix", "MASS", "sandwich")
  
  boot.res = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
    tryCatch({
      indices = sample(1:N, replace = TRUE)
      dat = original.dat[indices,]
      
      y = dat$y
      r = dat$r
      
      n = sum(dat$r == 1)
      
      auxilliary = auxilliary.f(dat)
      
      ################################################################################
      # Fit working propensity score models
      ################################################################################
      pi.fit.list = list()
      for(j in 1:length(propensity.list)){
        pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                      model.y = propensity.list[[j]]$model.y(y),
                                      model.x1.names = propensity.list[[j]]$model.x1.names,
                                      model.x2.names = propensity.list[[j]]$model.x2.names,
                                      w = propensity.list[[j]]$w, w.prime = propensity.list[[j]]$w.prime)
      }
      ################################################################################
      
      ################################################################################
      # The method of Chuang & Chao (2023)
      ################################################################################
      est.res = ChuangChao2023(pi.fit.list, auxilliary = auxilliary, family)
      est = unlist(est.res[1:4])
      ################################################################################
      
      ################################################################################
      # The method of Kim & Yu (2012)
      ################################################################################
      # mu.KimYu = NA
      # if(situation == 1 & wrong.num == 0){
      #   gamma = alpha.true[2]
      #   mu.KimYu = KimYu2012(gamma, y, u1, u2, z1, z2, r)
      # }
      ################################################################################
      
      ################################################################################
      # The method of Han (2018)
      ################################################################################
      # est.res = readRDS("y0_y1_est.RDS")
      # mu.Han = Han2018(est.res$outcome.list, est.res$pi.fit.list, family)
      ##################################
      
      c(mu.IPW = est[1], se.IPW = est[2], CC = mean(y[r == 1]))
    }, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
  }
  return(boot.res)
}
```

```{r}
perturb.bootstrap = function(propensity.list, auxilliary.f, dat, family, B){
  source("Wang2014_12.r", local = TRUE)
  source("Han2018_2.r", local = TRUE)
  source("KimYu2012.r", local = TRUE)
  source("ChuangChao2023_SM.r", local = TRUE)
  
  cores = detectCores()
  cl = makeCluster(cores - 2) ## number of clusters 
  registerDoSNOW(cl)
  
  pb = txtProgressBar(max = B, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts = list(progress = progress)
  parallel_packages = c("pracma", "tidyverse", "Matrix", "MASS", "sandwich")
  
  boot.res = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
    tryCatch({
      y = dat$y
      r = dat$r
      
      N = nrow(dat)
      n = sum(dat$r == 1)
      
      perturb = rexp(N, rate = 1)
      
      auxilliary = auxilliary.f(dat)
      
      ################################################################################
      # Fit working propensity score models
      ################################################################################
      pi.fit.list = list()
      for(j in 1:length(propensity.list)){
        pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                      model.y = propensity.list[[j]]$model.y(y),
                                      model.x1.names = propensity.list[[j]]$model.x1.names,
                                      model.x2.names = propensity.list[[j]]$model.x2.names,
                                      w = propensity.list[[j]]$w, 
                                      w.prime = propensity.list[[j]]$w.prime, perturb = perturb)
      }
      ################################################################################
      
      ################################################################################
      # The method of Chuang & Chao (2023)
      ################################################################################
      est.res = ChuangChao2023(pi.fit.list, auxilliary = auxilliary, family, perturb = perturb)
      est = unlist(est.res[1:4])
      ################################################################################
      
      ################################################################################
      # The method of Kim & Yu (2012)
      ################################################################################
      # mu.KimYu = NA
      # if(situation == 1 & wrong.num == 0){
      #   gamma = alpha.true[2]
      #   mu.KimYu = KimYu2012(gamma, y, u1, u2, z1, z2, r)
      # }
      ################################################################################
      
      ################################################################################
      # The method of Han (2018)
      ################################################################################
      # est.res = readRDS("y0_y1_est.RDS")
      # mu.Han = Han2018(est.res$outcome.list, est.res$pi.fit.list, family)
      ##################################
      
      c(mu.IPW = est[1], se.IPW = est[2], CC = mean(perturb[r == 1]*y[r == 1]))
    }, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
  }
  return(boot.res)
}
```

```{r}
perturb.bootstrap2 = function(est.res, exp.tilt.list, exp.tilt.model.x.names, auxilliary.f, dat, family, B){
  source("Wang2014_12.r", local = TRUE)
  source("Han2018_2.r", local = TRUE)
  source("KimYu2012.r", local = TRUE)
  source("ChuangChao2023_SM.r", local = TRUE)
  
  cores = detectCores()
  cl = makeCluster(cores - 2) ## number of clusters 
  registerDoSNOW(cl)
  
  pb = txtProgressBar(max = B, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts = list(progress = progress)
  parallel_packages = c("pracma", "tidyverse", "Matrix", "MASS", "sandwich")
  
  boot.res = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
    tryCatch({
      y = dat$y
      r = dat$r
      
      N = nrow(dat)
      n = sum(r == 1)
      
      perturb = rexp(N, rate = 1)
      
      auxilliary = auxilliary.f(dat)
      
      ################################################################################
      # Sensitivity analysis under mild misspecification condition
      ################################################################################
      mild.est.res = mild.est(est.res, exp.tilt.list, exp.tilt.model.x.names, 
                         auxilliary, family = "gaussian", perturb = perturb)
      est = unlist(mild.est.res[1:4])
      ################################################################################
      
      ################################################################################
      # The method of Kim & Yu (2012)
      ################################################################################
      # mu.KimYu = NA
      # if(situation == 1 & wrong.num == 0){
      #   gamma = alpha.true[2]
      #   mu.KimYu = KimYu2012(gamma, y, u1, u2, z1, z2, r)
      # }
      ################################################################################
      
      ################################################################################
      # The method of Han (2018)
      ################################################################################
      # est.res = readRDS("y0_y1_est.RDS")
      # mu.Han = Han2018(est.res$outcome.list, est.res$pi.fit.list, family)
      ##################################
      
      c(mu.IPW = est[1], se.IPW = est[2], CC = mean(perturb[r == 1]*y[r == 1]))
    }, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
  }
  return(boot.res)
}
```


```{r}
bootstrap.effect = function(propensity.list.list, auxilliary.f, effect.f, dat, family, B){
  source("Wang2014_12.r", local = TRUE)
  source("Han2018_2.r", local = TRUE)
  source("KimYu2012.r", local = TRUE)
  source("ChuangChao2023_SM.r", local = TRUE)
  
  N = nrow(dat)
  original.dat = dat
  
  cores = detectCores()
  cl = makeCluster(cores - 2) ## number of clusters 
  registerDoSNOW(cl)
  
  pb = txtProgressBar(max = B, style = 3)
  progress <- function(n) setTxtProgressBar(pb, n)
  opts = list(progress = progress)
  parallel_packages = c("pracma", "tidyverse", "Matrix", "MASS", "sandwich")
  
  boot.res = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
    tryCatch({
      indices = sample(1:N, replace = TRUE)
      boot.dat = original.dat[indices,]
      
      health.status = 0:1
      subset.names = c("health0", "health1")
      
      ################################################################################
      # Fit working propensity score models
      ################################################################################
      res = rep(NA, 8)
      m = 1
      for(model.num in 1:length(propensity.list.list[[1]])){
        model.sets = combn(3, model.num)
        for(i in 1:ncol(model.sets)){
          model.set = model.sets[, i]
          est = rep(NA, length(health.status))
          mu.cc = rep(NA, length(health.status))
          for(k in 1:length(health.status)){
            print(c(model.num, i, k))
            dat = boot.dat[boot.dat$health == health.status[k], ]
            
            N = nrow(dat)
            n = sum(dat$r)
            y = dat$y
            r = dat$r
            
            mu.cc[k] = mean(y[r == 1])
            auxilliary = auxilliary.f(dat)
            pi.fit.list = list()
            l = 1
            for(j in model.set){
              pi.fit.list[[l]] = Wang2014.1(auxilliary = auxilliary,
                                            model.y = propensity.list.list[[k]][[j]]$model.y(y),
                                            model.x1.names = propensity.list.list[[k]][[j]]$model.x1.names,
                                            model.x2.names = propensity.list.list[[k]][[j]]$model.x2.names,
                                            w = propensity.list.list[[k]][[j]]$w,
                                            w.prime = propensity.list.list[[k]][[j]]$w.prime)
              l = l + 1
            }
            est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
            est[k] = unlist(est.res[1])
          }
          effect = effect.f(est[1], est[2])
          res[m] = c(effect)
          m = m + 1
        }
      }
      ################################################################################
      
      res[8] = mu.cc[2]/mu.cc[1]
      ################################################################################
      # The method of Kim & Yu (2012)
      ################################################################################
      # mu.KimYu = NA
      # if(situation == 1 & wrong.num == 0){
      #   gamma = alpha.true[2]
      #   mu.KimYu = KimYu2012(gamma, y, u1, u2, z1, z2, r)
      # }
      ################################################################################
      
      ################################################################################
      # The method of Han (2018)
      ################################################################################
      # est.res = readRDS("y0_y1_est.RDS")
      # mu.Han = Han2018(est.res$outcome.list, est.res$pi.fit.list, family)
      ##################################
      
      res
    }, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
  }
  return(boot.res)
}
```

```{r}
rm.extreme = function(v){
  z.score = scale(v)
  v = v[abs(z.score) <= 3]
  print(sum(abs(z.score) > 3))
  return(v)
}
```

```{r}
show.alpha = function(est.res){
  lapply(est.res$outcome.list, function(outcome.fit) print(round(summary(outcome.fit)$coef, 4)))
  alpha.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$theta.hat)
  alpha.se.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$se)
  for(i in 1:length(alpha.list)){
    alpha.list[[i]] = rbind(alpha.list[[i]], alpha.se.list[[i]]) 
    p.value = (1-pnorm(abs(alpha.list[[i]][1,]/alpha.list[[i]][2,])))*2
    alpha.list[[i]] = rbind(alpha.list[[i]], p.value)
    rownames(alpha.list[[i]]) = c("Estimate", "SE", "p-value")
  }
  par(mfrow = c(1, 2))
  boxplot(est.res$pi.m, ylim = c(0, 1))
  boxplot(est.res$pi.m%*%est.res$w.pi, ylim = c(0, 1))
  return(alpha.list)
}
```

```{r}
settings = c("MNAR", "MAR")
```

## Results of Ibrahim (2001) and ZhaoMa (2022)

### ZhaoMa (2022)

```{r}
odds.ratio = function(p1, p0){
  (p1/(1-p1))/(p0/(1-p0))
}
odds.ratio.se = function(p1, p1.se, p0, p0.se){
  odds.ratio(p1, p0)*sqrt(1/((p1*(1-p1))^2)*(p1.se^2)+1/((p0*(1-p0))^2)*(p0.se^2))
}
```

```{r}
beta.ibrahim = c(-1.7938, -0.0641, -0.1610, 1.4538)
eta.ibrahim = cbind(rep(1, N), dat$health, dat$father, dat$parent_report)%*%beta.ibrahim
mean(exp(eta.ibrahim)/(1+exp(eta.ibrahim)))
```

```{r}
dat = original.dat
N = nrow(dat)

beta.zhaoma = c(-1.3585, -0.9817, -0.0718, 1.4623)
beta.se.zhaoma = c(0.1823, 0.1470, 0.1320, 0.1194)

eta.zhaoma = cbind(rep(1, N), dat$health, dat$father, dat$parent_report)%*%beta.zhaoma
overall.muhat = mean(exp(eta.zhaoma)/(1+exp(eta.zhaoma)))

eta.zhaoma = cbind(rep(1, N), rep(1, N), dat$father, dat$parent_report)%*%beta.zhaoma
health1.muhat = mean(exp(eta.zhaoma)/(1+exp(eta.zhaoma)))
  
eta.zhaoma = cbind(rep(1, N), rep(0, N), dat$father, dat$parent_report)%*%beta.zhaoma
health0.muhat = mean(exp(eta.zhaoma)/(1+exp(eta.zhaoma)))

eta.zhaoma = cbind(rep(1, N), dat$health, rep(1, N), dat$parent_report)%*%beta.zhaoma
father1.muhat = mean(exp(eta.zhaoma)/(1+exp(eta.zhaoma)))
  
eta.zhaoma = cbind(rep(1, N), dat$health, rep(0, N), dat$parent_report)%*%beta.zhaoma
father0.muhat = mean(exp(eta.zhaoma)/(1+exp(eta.zhaoma)))

zhaoma.health.res = matrix(c(health1.muhat, health0.muhat, odds.ratio(health1.muhat, health0.muhat)), 1, 3)
zhaoma.father.res = matrix(c(father1.muhat, father0.muhat, odds.ratio(father1.muhat, father0.muhat)), 1, 3)

zhaoma.health.res
zhaoma.father.res
```

#### Mean estimate

```{r}
colnames(zhaoma.health.res) =  c("health = 1", "health = 0", "odds ratio")
kable(zhaoma.health.res, align = "c", booktabs = TRUE, escape = FALSE) %>%
  kable_styling(full_width = F, latex_options = c("hold_position"))
```

#### The odds ratio of Health = 1 vs Health = 0

```{r, eval = FALSE}
subset.name = "health"
est.res1 = readRDS(paste0("MHDResults/MNAR_est_", subset.name, "1.RDS"))
est.res0 = readRDS(paste0("MHDResults/MNAR_est_", subset.name, "0.RDS"))
est1 = unlist(est.res1[1:7])
est0 = unlist(est.res0[1:7])
se1 = c(unlist(est.res1[8:12]), 0, unlist(est.res1[13]))
se0 = c(unlist(est.res0[8:12]), 0, unlist(est.res0[13]))
res = odds.ratio(est1, est0)
res = cbind(res, odds.ratio.se(est1, se1, est0, se0))
res = cbind(round(res, 4), apply(cbind(res[, 1] - qnorm(0.975)*res[, 2], res[, 1] + qnorm(0.975)*res[, 2]), 1, 
           function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))
rownames(res) = c("IPW", "UMR", "AIPW.m1", "AIPW.m0", "AIPW.m", "AIPW.h.opt", "GMM")
colnames(res) = c("Odds Ratio", "SE", "$95\\%$ CI")
kable(res, align = "c", booktabs = TRUE, escape = FALSE) %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) 
```

#### The odds ratio of Father = 1 vs Father = 0

```{r, eval = FALSE}
subset.name = "father"
est.res1 = readRDS(paste0("MHDResults/MNAR.allm_est_", subset.name, "1.RDS"))
est.res0 = readRDS(paste0("MHDResults/MNAR.allm_est_", subset.name, "0.RDS"))
est1 = unlist(est.res1[1:7])
est0 = unlist(est.res0[1:7])
se1 = c(unlist(est.res1[8:12]), 0, unlist(est.res1[13]))
se0 = c(unlist(est.res0[8:12]), 0, unlist(est.res0[13]))
res = odds.ratio(est1, est0)
res = cbind(res, odds.ratio.se(est1, se1, est0, se0))
res = cbind(round(res, 4), apply(cbind(res[, 1] - qnorm(0.975)*res[, 2], res[, 1] + qnorm(0.975)*res[, 2]), 1, 
           function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))
rownames(res) = c("IPW", "UMR", "AIPW.m1", "AIPW.m0", "AIPW.m", "AIPW.h.opt", "GMM")
colnames(res) = c("Odds Ratio", "SE", "$95\\%$ CI")
kable(res, align = "c", booktabs = TRUE, escape = FALSE) %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) 
```

```{r eval=FALSE}
dat = original.dat
y = dat$y
r = dat$r

cc.fit = glm(y~parent_report+health+father, dat, family = binomial(), subset = r == 1)
theta.init = cc.fit$coef

est = ZhaoMa2022(dat$y, dat$parent_report, cbind(dat$health, dat$father), dat$r, 
                 init = theta.init)$theta.hat
```

## Overall data

```{r}
situation = 1
wrong.num = 1
boot = TRUE; B = 500;
```

### Code

```{r}
dat = original.dat

dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

propensity.list.0 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = NULL,
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("father", "parent_report"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL))

propensity.list.1 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = NULL,
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("father"), ###
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL))

propensity.list.list = list(propensity.list.0, propensity.list.1)
```

```{r, eval = FALSE}
# auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report), as.factor(dat$father*dat$parent_report)),
#                   NULL)
auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report)),
                  NULL)

health.status = 0:1
subset.names = c("health0", "health1")

# effect.f = function(x, y) y/x
# delta.method = function(x, y) c(-y/x^2, 1/x)

effect.f = function(x, y) (y/(1-y))/(x/(1-x))
delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
                                ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

# effect.f = function(x, y) log((y/(1-y))/(x/(1-x)))
# delta.method = function(x, y) (x/(1-x))/(y/(1-y))*c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
#                                 ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

################################################################################
# Fit working propensity score models
################################################################################
res = matrix(NA, 8, 2)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    model.set = model.sets[, i]
    est = matrix(NA, length(health.status), 2)
    for(k in 1:length(health.status)){
      print(c(model.num, i, k))
      dat = original.dat[original.dat$health == health.status[k], ]
      N = nrow(dat)
      n = sum(dat$r)
      y = dat$y
      r = dat$r
      auxilliary = auxilliary.f(dat)
      pi.fit.list = list()
      l = 1
      for(j in model.set){
        pi.fit.list[[l]] = Wang2014.1(auxilliary = auxilliary,
                                      model.y = propensity.list.list[[k]][[j]]$model.y(y),
                                      model.x1.names = propensity.list.list[[k]][[j]]$model.x1.names,
                                      model.x2.names = propensity.list.list[[k]][[j]]$model.x2.names,
                                      w = propensity.list.list[[k]][[j]]$w,
                                      w.prime = propensity.list.list[[k]][[j]]$w.prime)
        l = l + 1
      }
      est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
      saveRDS(est.res,
              paste0(c("MHDResults/MNAR_est_", subset.names[k], "_", model.set, "_OR5.RDS"), collapse = ""))
      est[k, ] = unlist(est.res[1:3])
    }
    effect = effect.f(est[1, 1], est[2, 1])
    Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
    se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
    res[m, ] = c(effect, se)
    m = m + 1
  }
}
################################################################################

cc1 = original.dat$health == 1 & original.dat$r == 1
cc0 = original.dat$health == 0 & original.dat$r == 1
mu.cc1 = mean(original.dat[cc1, ]$y)
se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
mu.cc0 = mean(original.dat[cc0, ]$y)
se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
res[8, ] = c(effect.f(mu.cc0, mu.cc1),
             sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
```

```{r}
# auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report), as.factor(dat$father*dat$parent_report)),
#                   NULL)
auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report)),
                  NULL)

health.status = 0:1
subset.names = c("health0", "health1")


effect.f = function(x, y) (y/(1-y))/(x/(1-x))
delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
                                ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

res = matrix(NA, 20, 2)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    est = matrix(NA, length(health.status), 2)
    model.set0 = model.sets[, i]
    est.res0 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[1], "_", model.set0, "_OR5.RDS"), collapse = ""))
    est[1, ] = unlist(est.res0[1:3])
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      est.res1 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[2], "_", model.set1, "_OR5.RDS"), collapse = ""))
      est[2, ] = unlist(est.res1[1:3])
      effect = effect.f(est[1, 1], est[2, 1])
      Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
      se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
      res[m, ] = c(effect, se)
      m = m + 1
    }
  }
}
cc1 = original.dat$health == 1 & original.dat$r == 1
cc0 = original.dat$health == 0 & original.dat$r == 1
mu.cc1 = mean(original.dat[cc1, ]$y)
se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
mu.cc0 = mean(original.dat[cc0, ]$y)
se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
res[20, ] = c(effect.f(mu.cc0, mu.cc1),
             sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
res.tmp = res
```

```{r eval = FALSE}
################################################################################
# Bootstrap
################################################################################
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    model.set = model.sets[, i]
    for(k in 1:2) {
      print(c(model.num, i, k))
      dat = original.dat[original.dat$health == health.status[k], ]
      boot.res = perturb.bootstrap(propensity.list.list[[k]][model.set], auxilliary.f, dat, family, B)
      save.file = paste0(c("MHDResults/MNAR_pboot_est_", subset.names[k], "_", model.set, "_OR16.RDS"), collapse = "")
      if(file.exists(save.file)){
        boot.res = cbind(readRDS(save.file), boot.res)
        saveRDS(boot.res, save.file)
      }else{
        saveRDS(boot.res, save.file)
      }
      print("")
      print(apply(boot.res, 1, mean))
      print(apply(boot.res, 1, sd))
      gc()
    }
  }
}
################################################################################
```

```{r eval = FALSE}
################################################################################
# Bootstrap (not this)
################################################################################
if(boot){
  for(i in 1:50){
    boot.res = bootstrap.effect(propensity.list.list,
                       auxilliary.f, effect.f, original.dat, family,  B)
    save.file = "MHDResults/MNAR_est_boot_health_effect_OR2.RDS"
    if(file.exists(save.file)){
      boot.res = cbind(readRDS(save.file), boot.res)
      saveRDS(boot.res, save.file)
    }else{
      saveRDS(boot.res, save.file)
    }
    print("")
    print(apply(boot.res, 1, mean))
    print(apply(boot.res, 1, sd))
    gc()
  }
}
################################################################################
```

### Results

```{r}
# boot.res = readRDS("MHDResults/MNAR_est_boot_health_effect_OR2.RDS")
# par(mfrow = c(2, 4))
# for(i in 1:nrow(boot.res)) hist(boot.res[i, ])
```

```{r}
boot.res.se = boot.res.CI =  boot.res.se.mean = boot.res.se.CI = rep(NA, 20)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    model.set0 = model.sets[, i]
    boot.res0 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[1], "_", model.set0, "_OR15.RDS"), collapse = ""))
    boot.res = matrix(NA, length(health.status)*2, ncol(boot.res0))
    boot.res[1, ] = boot.res0[1, ]
    boot.res[3, ] = boot.res0[2, ]
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      boot.res1 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[2], "_", model.set1, "_OR15.RDS"), collapse = ""))
      boot.res[2, ] = boot.res1[1, ]
      boot.res[4, ] = boot.res1[2, ]
      
      # boot.effect = apply(boot.res[1:2, ], 2, function(v) effect.f(v[1], v[2]))
      # boot.res.CI[m] = paste0(c("[", paste(round(quantile(boot.effect, c(0.025, 0.975)), 4), collapse = ", "),
      #                              "]"), collapse =  "")
      # boot.res.se[m] = sd(boot.effect)
      boot.mu.hat = apply(boot.res[1:2, ], 1, function(v) mean(rm.extreme(v)))
      boot.var = apply(boot.res[1:2, ], 1, function(v) var(rm.extreme(v)))
      boot.res.se[m] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)

      # boot.se = sqrt(apply(boot.res, 2, function(v) delta.method(v[1], v[2])^2%*%c(v[3]^2, v[4]^2)))
      # boot.res.se.mean[m] = round(mean(boot.se), 4)
      # boot.res.se.CI[m] = paste0(c("[", paste(round(quantile(boot.se, c(0.025, 0.975)), 4), collapse = ", "),
      #                              "]"), collapse =  "")
      m = m + 1
    }
  }
}
boot.res[1,] = boot.res0[3, ]
boot.res[2,] = boot.res1[3, ]
# boot.effect = apply(boot.res, 2, function(v) effect.f(v[1], v[2]))
# boot.res.se[20] = sd(boot.effect)
boot.mu.hat = apply(boot.res[1:2, 1:B], 1, function(v) mean(rm.extreme(v)))
boot.var = apply(boot.res[1:2, 1:B], 1, function(v) var(rm.extreme(v)))
boot.res.se[20] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)
```

```{r}
res = res.tmp
res = cbind(res, boot.res.se)
res = as.data.frame(res)
res = cbind(round(res, 3),
            apply(cbind(res[, 1] - qnorm(0.975)*res[, 2], res[, 1] + qnorm(0.975)*res[, 2]), 1, 
                  function(v) paste0("[", round(v[1], 3) , ", ", round(v[2], 3), "]")))

rownames(res) = c("$\\hat{\\theta}_{100}^{100}$", "$\\hat{\\theta}_{100}^{010}$", "$\\hat{\\theta}_{100}^{001}$",
                  "$\\hat{\\theta}_{010}^{100}$", "$\\hat{\\theta}_{010}^{010}$", "$\\hat{\\theta}_{010}^{001}$",
                  "$\\hat{\\theta}_{001}^{100}$", "$\\hat{\\theta}_{001}^{010}$", "$\\hat{\\theta}_{001}^{001}$",
                  "$\\hat{\\theta}_{110}^{110}$", "$\\hat{\\theta}_{110}^{101}$", "$\\hat{\\theta}_{110}^{011}$",
                  "$\\hat{\\theta}_{101}^{110}$", "$\\hat{\\theta}_{101}^{101}$", "$\\hat{\\theta}_{101}^{011}$",
                  "$\\hat{\\theta}_{011}^{110}$", "$\\hat{\\theta}_{011}^{101}$", "$\\hat{\\theta}_{011}^{011}$",
                  "$\\hat{\\theta}_{111}^{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(res) = c("PE", "SE", "Bootstrap SE", "$95\\%$ CI")
kable(res, align = "c", booktabs = TRUE, escape = FALSE, linesep = "",
      caption = "") %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) %>%
  row_spec(9, hline_after = T) %>%
  row_spec(18, hline_after = T) %>%
  row_spec(19, hline_after = T) 
```

```{r}
res = res[-20, ]
res$estimator <- 1:nrow(res)

# Calculate the confidence intervals
res$lower_bound <- res$PE - 1.96 * res$SE
res$upper_bound <- res$PE + 1.96 * res$SE

# Create the plot
par(mgp = c(3, 2.8, 0), mar = c(5, 5, 4, 2) + 0.1)
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "", ylab = "", pch = symbols, 
     main = "", xaxt = "n", cex = 2, cex.axis = 1.8)

abline(h = 1, col = "black",lty = 1, lwd = 4)
# abline(h = res$PE[19], col = "darkgrey",lty = 3, lwd = 4)
abline(v = 9.5, col = "darkgrey",lty = 2, lwd = 4)
abline(v = 18.5, col = "darkgrey",lty = 2, lwd = 4)

arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound,
       angle = 90, code = 3, length = 0.05, lwd = 4, col = "grey40")
lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 5)
# points(res$estimator[setdiff(1:19, c(9, 14:15, 17:19))],
#        res$PEsetdiff[setdiff(1:19, c(9, 14:15, 17:19))], pch = 16)
# points(res$estimator[c(9, 14:15, 17:19)],
#        res$PEsetdiff[c(9, 14:15, 17:19)], pch = 11)
symbols = rep(NA, 19)
symbols[setdiff(1:19, c(9, 14:15, 17:19))] = 18
symbols[c(9, 14:15, 17:19)] = 15

axis(1, at = res$estimator,
     labels = c(expression(hat(theta)["100"]^"100"), expression(hat(theta)["100"]^"010"), expression(hat(theta)["100"]^"001"),
                expression(hat(theta)["010"]^"100"), expression(hat(theta)["010"]^"010"), expression(hat(theta)["010"]^"001"),
                expression(hat(theta)["001"]^"100"), expression(hat(theta)["001"]^"010"), expression(hat(theta)["001"]^"001"),
                expression(hat(theta)["110"]^"110"), expression(hat(theta)["110"]^"101"), expression(hat(theta)["110"]^"011"),
                expression(hat(theta)["101"]^"110"), expression(hat(theta)["101"]^"101"), expression(hat(theta)["101"]^"011"),
                expression(hat(theta)["011"]^"110"), expression(hat(theta)["011"]^"101"), expression(hat(theta)["011"]^"011"),
                expression(hat(theta)["111"]^"111")), cex.axis = 2)
text(c(1, 3, 9, 14:15, 17:18, 19),  res$upper_bound[c(1, 3, 9, 14:15, 17:18, 19)] + 0.05, "*", cex=2, col="black")
# rect(0.5, par("usr")[3], 9.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
# rect(9.5, par("usr")[3], 18.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
# rect(18.5, par("usr")[3], 19.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

```{r}
res = res[-20, ]
res$estimator <- 1:nrow(res)

# Calculate the confidence intervals
res$lower_bound <- res$PE - 1.96 * res$SE
res$upper_bound <- res$PE + 1.96 * res$SE

# Create the plot
par(mgp = c(3, 2.8, 0), mar = c(5, 5, 4, 2) + 0.1)
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "", ylab = "", pch = 16, 
     main = "", xaxt = "n", cex = 2, cex.axis = 1.8)

arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 4, col = "grey40")
lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 5)
points(res$estimator, res$PE, pch = 16)
axis(1, at = res$estimator,
     labels = c(expression(hat(theta)["100"]^"100"), expression(hat(theta)["100"]^"010"), expression(hat(theta)["100"]^"001"),
                expression(hat(theta)["010"]^"100"), expression(hat(theta)["010"]^"010"), expression(hat(theta)["010"]^"001"),
                expression(hat(theta)["001"]^"100"), expression(hat(theta)["001"]^"010"), expression(hat(theta)["001"]^"001"),
                expression(hat(theta)["110"]^"110"), expression(hat(theta)["110"]^"101"), expression(hat(theta)["110"]^"011"),
                expression(hat(theta)["101"]^"110"), expression(hat(theta)["101"]^"101"), expression(hat(theta)["101"]^"011"),
                expression(hat(theta)["011"]^"110"), expression(hat(theta)["011"]^"101"), expression(hat(theta)["011"]^"011"),
                expression(hat(theta)["111"]^"111")), cex.axis = 2)
text(c(6, 11:12, 17:19),  res$upper_bound[c(6, 11:12, 17:19)] + 0.1, "*", cex=2, col="black")
abline(h = 1, col = "black",lty = 1, lwd = 4)
abline(v = 9.5, col = "darkgrey",lty = 2, lwd = 4)
abline(v = 18.5, col = "darkgrey",lty = 2, lwd = 4)
# rect(0.5, par("usr")[3], 9.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
# rect(9.5, par("usr")[3], 18.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
# rect(18.5, par("usr")[3], 19.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

```{r, eval=FALSE}
res = res[-8, ]
res$estimator <- 1:nrow(res)

boot.CI = t(apply(boot.res, 1, quantile, c(0.025, 0.975)))[1:7,]

# Calculate the confidence intervals
res$lower_bound <- boot.CI[, 1]
res$upper_bound <- boot.CI[, 2]

# Create the plot
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "Estimator", ylab = "Estimate", pch = 16, 
     main = "PE with 95% bootstrap CI", xaxt = "n")

lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 2)
arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 2)
axis(1, at = res$estimator, 
     labels = c(expression(hat(mu)["100"]), expression(hat(mu)["010"]), expression(hat(mu)["001"]),
                   expression(hat(mu)["110"]), expression(hat(mu)["101"]), expression(hat(mu)["011"]),
                   expression(hat(mu)["111"])))
abline(h = 1, col = "red",lty = 2, lwd = 2)
rect(0.5, par("usr")[3], 3.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
rect(3.5, par("usr")[3], 6.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
rect(6.5, par("usr")[3], 7.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

## Overall data (Mild misspecification)

```{r}
situation = 1
wrong.num = 1
boot = TRUE; B = 500;
```

### Code

```{r}
dat = original.dat

dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

propensity.list.0 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = NULL,
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("father", "parent_report"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL))

propensity.list.1 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = NULL,
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL))

propensity.list.list = list(propensity.list.0, propensity.list.1)
```

```{r}
auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report)),
                  NULL)

health.status = 0:1
subset.names = c("health0", "health1")

# effect.f = function(x, y) y/x
# delta.method = function(x, y) c(-y/x^2, 1/x)

effect.f = function(x, y) (y/(1-y))/(x/(1-x))
delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
                                ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

true.index = c(3, 3)
zeta.v = seq(-0.5, -0.05, length.out = 30)
xi.v = N^(zeta.v)
xi.v = seq(0, N^(-0.5), length.out = 30)
res = matrix(NA, length(xi.v), 2)
m = 1
for(xi in xi.v){
  est = matrix(NA, length(health.status), 2)
  for(k in 1:length(health.status)){
    dat = original.dat[original.dat$health == health.status[k], ]
    N = nrow(dat)
    n = sum(dat$r)
    y = dat$y
    r = dat$r
    auxilliary = auxilliary.f(dat)
    pi.fit.list = list()
    l = 1
    for(j in 1:length(propensity.list.list[[k]])){
      pi.fit.list[[l]] = Wang2014.1(auxilliary = auxilliary,
                                    model.y = propensity.list.list[[k]][[j]]$model.y(y),
                                    model.x1.names = propensity.list.list[[k]][[j]]$model.x1.names,
                                    model.x2.names = propensity.list.list[[k]][[j]]$model.x2.names,
                                    w = propensity.list.list[[k]][[j]]$w,
                                    w.prime = propensity.list.list[[k]][[j]]$w.prime)
      l = l + 1
    }
    est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
    exp.tilt = function(y, x) exp(xi*as.matrix(cbind(y))%*%rep(1, ncol(cbind(y))))
    exp.tilt.x.names = NULL
    mild.est.res = mild.est(pi.m = est.res$pi.m, true.index = true.index[k], exp.tilt = exp.tilt, exp.tilt.x.names = exp.tilt.x.names, 
                            auxilliary, family = "gaussian")
    saveRDS(mild.est.res,
            paste0(c("MHDResults/MNAR_est_", subset.names[k], "_", 1:3, "_mild", round(xi, 3), "_OR5.RDS"), collapse = ""))
    print(mild.est.res$w.pi)
    est[k, ] = unlist(mild.est.res[c(1, 2)])
  }
  effect = effect.f(est[1, 1], est[2, 1])
  Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
  se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
  res[m, ] = c(effect, se)
  m = m + 1
}
```

```{r}
health.status = 0:1
subset.names = c("health0", "health1")

# effect.f = function(x, y) y/x
# delta.method = function(x, y) c(-y/x^2, 1/x)

effect.f = function(x, y) (y/(1-y))/(x/(1-x))
delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
                                ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

true.index = c(3, 3)
zeta.v = seq(-0.5, -0.05, length.out = 30)
xi.v = N^(zeta.v)
xi.v = seq(0, N^(-0.05), length.out = 30)
xi.v = seq(0, N^(-0.5), length.out = 30)
res = matrix(NA, length(xi.v), 2)
m = 1
for(xi in xi.v){
  est = matrix(NA, length(health.status), 2)
  for(k in 1:length(health.status)){
    mild.est.res = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[k], "_", 1:3, "_mild", round(xi, 3), "_OR5.RDS"), collapse = ""))
    print(mild.est.res$w.pi)
    est[k, ] = unlist(mild.est.res[c(1, 2)])
  }
  effect = effect.f(est[1, 1], est[2, 1])
  Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
  se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
  res[m, ] = c(effect, se)
  m = m + 1
}

# Create the plot
plot(cbind(xi.v, res[, 1]), type = "o",
     xlab = expression(xi), 
     ylab = "",  # Remove default ylab to add custom label
     las = 1)  # Ensure axis labels are horizontal

# Add the y-axis label manually with horizontal rotation
mtext(expression(hat(theta)), side = 2, line = 3, at = mean(par("usr")[3:4]), cex = 1, las = 1)
points(zeta.v, res[, 1], pch = 16)
abline(h = 1, lwd = 2)
```

### Code

```{r}
# dat = original.dat
# 
# dat$fh = dat$father*dat$health 
# dat$fp = dat$father*dat$parent_report
# dat$hp = dat$health*dat$parent_report
# 
# propensity.list.0 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
#                                  w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
#                                  model.y = function(y) y,
#                                  model.x1.names = c("parent_report"),
#                                  model.x2.names = NULL),
#                             list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
#                                  w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
#                                  model.y = function(y) NULL,
#                                  model.x1.names = c("father", "parent_report"),
#                                  model.x2.names = NULL),
#                             list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
#                                  w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
#                                  model.y = function(y) y,
#                                  model.x1.names = c("father"),
#                                  model.x2.names = NULL))
# 
# propensity.list.1 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
#                                  w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
#                                  model.y = function(y) y,
#                                  model.x1.names = NULL,
#                                  model.x2.names = NULL),
#                             list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
#                                  w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
#                                  model.y = function(y) NULL,
#                                  model.x1.names = c("father"),
#                                  model.x2.names = NULL),
#                             list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
#                                  w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
#                                  model.y = function(y) y,
#                                  model.x1.names = c("father"),
#                                  model.x2.names = NULL))
# 
# propensity.list.list = list(propensity.list.0, propensity.list.1)
# 
# exp.tilt.list =list(function(y, x, N) exp((N^(-1/1))*as.matrix(cbind(y))%*%rep(1, ncol(cbind(y)))),
#                     function(y, x, N) exp((N^(-1/3))*as.matrix(cbind(y, x))%*%rep(-1, ncol(cbind(y, x)))),
#                     function(y, x, N) exp((N^(-1/5))*as.matrix(cbind(x))%*%rep(1, ncol(cbind(x)))))
# exp.tilt.model.x.names = c("parent_report", "father")
```

```{r, eval = FALSE}
# auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report), as.factor(dat$father*dat$parent_report)),
#                   NULL)
# 
# health.status = 0:1
# subset.names = c("health0", "health1")
# 
# # effect.f = function(x, y) y/x
# # delta.method = function(x, y) c(-y/x^2, 1/x)
# 
# effect.f = function(x, y) (y/(1-y))/(x/(1-x))
# delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
#                                 ((1/y^2)/((1/y-1)^2))/(x/(1-x)))
# 
# # effect.f = function(x, y) log((y/(1-y))/(x/(1-x)))
# # delta.method = function(x, y) (x/(1-x))/(y/(1-y))*c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
# #                                 ((1/y^2)/((1/y-1)^2))/(x/(1-x)))
# 
# ################################################################################
# # Fit working propensity score models
# ################################################################################
# est.res.list = list()
# for(k in 1:length(health.status)){
#     dat = original.dat[original.dat$health == health.status[k], ]
#     N = nrow(dat)
#     n = sum(dat$r)
#     y = dat$y
#     r = dat$r
#     auxilliary = auxilliary.f(dat)
#     pi.fit.list = list()
#     l = 1
#     for(j in 1:length(propensity.list.list[[k]])){
#       pi.fit.list[[l]] = Wang2014.1(auxilliary = auxilliary,
#                                     model.y = propensity.list.list[[k]][[j]]$model.y(y),
#                                     model.x1.names = propensity.list.list[[k]][[j]]$model.x1.names,
#                                     model.x2.names = propensity.list.list[[k]][[j]]$model.x2.names,
#                                     w = propensity.list.list[[k]][[j]]$w,
#                                     w.prime = propensity.list.list[[k]][[j]]$w.prime)
#       l = l + 1
#     }
#     est.res.list[[k]] = ChuangChao2023(pi.fit.list, auxilliary, family)
# }
```

```{r, eval=FALSE}
# ################################################################################
# # Fit working propensity score models
# ################################################################################
# res = matrix(NA, 8, 2)
# m = 1
# for(model.num in 1:3){
#   model.sets = combn(3, model.num)
#   for(i in 1:ncol(model.sets)){
#     model.set = model.sets[, i]
#     est = matrix(NA, length(health.status), 2)
#     for(k in 1:length(health.status)){
#       print(c(model.num, i, k))
#       dat = original.dat[original.dat$health == health.status[k], ]
#       N = nrow(dat)
#       n = sum(dat$r)
#       y = dat$y
#       r = dat$r
#       auxilliary = auxilliary.f(dat)
#       mild.est.res = mild.est(est.res.list[[k]], exp.tilt.list[model.set], exp.tilt.model.x.names, 
#                          auxilliary, family = "gaussian")
#       saveRDS(mild.est.res,
#               paste0(c("MHDResults/MNAR_est_", subset.names[k], "_", model.set, "_mild_OR3.RDS"), collapse = ""))
#       est[k, ] = unlist(mild.est.res[c(1, 3)])
#       print(mild.est.res$w.pi)
#     }
#     effect = effect.f(est[1, 1], est[2, 1])
#     Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
#     se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
#     res[m, ] = c(effect, se)
#     m = m + 1
#   }
# }
# ################################################################################
# 
# cc1 = original.dat$health == 1 & original.dat$r == 1
# cc0 = original.dat$health == 0 & original.dat$r == 1
# mu.cc1 = mean(original.dat[cc1, ]$y)
# se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
# mu.cc0 = mean(original.dat[cc0, ]$y)
# se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
# Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
# res[8, ] = c(effect.f(mu.cc0, mu.cc1),
#              sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
```

```{r}
# res = matrix(NA, 20, 2)
# m = 1
# for(model.num in 1:3){
#   model.sets = combn(3, model.num)
#   for(i in 1:ncol(model.sets)){
#     print(c(model.num, i))
#     est = matrix(NA, length(health.status), 2)
#     model.set0 = model.sets[, i]
#     est.res0 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[1], "_", model.set0, "_mild_OR3.RDS"), collapse = ""))
#     est[1, ] = unlist(est.res0[c(1, 3)])
#     for(j in 1:ncol(model.sets)){
#       model.set1 = model.sets[, j]
#       est.res1 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[2], "_", model.set1, "_mild_OR3.RDS"), collapse = ""))
#       est[2, ] = unlist(est.res1[c(1, 3)])
#       effect = effect.f(est[1, 1], est[2, 1])
#       Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
#       se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
#       res[m, ] = c(effect, se)
#       m = m + 1
#     }
#   }
# }
# cc1 = original.dat$health == 1 & original.dat$r == 1
# cc0 = original.dat$health == 0 & original.dat$r == 1
# mu.cc1 = mean(original.dat[cc1, ]$y)
# se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
# mu.cc0 = mean(original.dat[cc0, ]$y)
# se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
# Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
# res[20, ] = c(effect.f(mu.cc0, mu.cc1),
#              sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
# res.tmp = res
```

```{r eval = FALSE}
# ################################################################################
# # Bootstrap
# ################################################################################
# for(model.num in 1:3){
#   model.sets = combn(3, model.num)
#   for(i in 1:ncol(model.sets)){
#     model.set = model.sets[, i]
#     for(k in 1:2) {
#       print(c(model.num, i, k))
#       dat = original.dat[original.dat$health == health.status[k], ]
#       boot.res = perturb.bootstrap2(est.res.list[[k]], exp.tilt.list, exp.tilt.model.x.names,
#                                     auxilliary.f, dat, family, B)
#       save.file = paste0(c("MHDResults/MNAR_boot_est_", subset.names[k], "_", model.set, "_mild_OR13.RDS"), collapse = "")
#       if(file.exists(save.file)){
#         boot.res = cbind(readRDS(save.file), boot.res)
#         saveRDS(boot.res, save.file)
#       }else{
#         saveRDS(boot.res, save.file)
#       }
#       print("")
#       print(apply(boot.res, 1, mean))
#       print(apply(boot.res, 1, sd))
#       gc()
#     }
#   }
# }
# ################################################################################
```

### Results

```{r}
# boot.res = readRDS("MHDResults/MNAR_est_boot_health_effect_OR2.RDS")
# par(mfrow = c(2, 4))
# for(i in 1:nrow(boot.res)) hist(boot.res[i, ])
```

```{r}
boot.res.se = boot.res.CI =  boot.res.se.mean = boot.res.se.CI = rep(NA, 20)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    model.set0 = model.sets[, i]
    boot.res0 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[1], "_", model.set0, "_mild_OR13.RDS"), collapse = ""))
    boot.res = matrix(NA, length(health.status)*2, ncol(boot.res0))
    boot.res[1, ] = boot.res0[1, ]
    boot.res[3, ] = boot.res0[2, ]
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      boot.res1 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[2], "_", model.set1, "_mild_OR13.RDS"), collapse = ""))
      boot.res[2, ] = boot.res1[1, ]
      boot.res[4, ] = boot.res1[2, ]
      
      boot.mu.hat = apply(boot.res[1:2, ], 1, function(v) mean(rm.extreme(v)))
      boot.var = apply(boot.res[1:2, ], 1, function(v) var(rm.extreme(v)))
      boot.res.se[m] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)

      m = m + 1
    }
  }
}
boot.res[1,] = boot.res0[3, ]
boot.res[2,] = boot.res1[3, ]
boot.mu.hat = apply(boot.res[1:2, 1:1000], 1, function(v) mean(rm.extreme(v)))
boot.var = apply(boot.res[1:2, 1:1000], 1, function(v) var(rm.extreme(v)))
boot.res.se[20] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)
```

```{r}
res = res.tmp
res = cbind(res, boot.res.se)
res = as.data.frame(res)
res = cbind(round(res, 4),
            apply(cbind(res[, 1] - qnorm(0.975)*res[, 2], res[, 1] + qnorm(0.975)*res[, 2]), 1, 
                  function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))

rownames(res) = c("$\\hat{\\theta}_{100}^{100}$", "$\\hat{\\theta}_{100}^{010}$", "$\\hat{\\theta}_{100}^{001}$",
                  "$\\hat{\\theta}_{010}^{100}$", "$\\hat{\\theta}_{010}^{010}$", "$\\hat{\\theta}_{010}^{001}$",
                  "$\\hat{\\theta}_{001}^{100}$", "$\\hat{\\theta}_{001}^{010}$", "$\\hat{\\theta}_{001}^{001}$",
                  "$\\hat{\\theta}_{110}^{110}$", "$\\hat{\\theta}_{110}^{101}$", "$\\hat{\\theta}_{110}^{011}$",
                  "$\\hat{\\theta}_{101}^{110}$", "$\\hat{\\theta}_{101}^{101}$", "$\\hat{\\theta}_{101}^{011}$",
                  "$\\hat{\\theta}_{011}^{110}$", "$\\hat{\\theta}_{011}^{101}$", "$\\hat{\\theta}_{011}^{011}$",
                  "$\\hat{\\theta}_{111}^{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(res) = c("PE", "SE", "Bootstrap SE", "$95\\%$ CI")
kable(res, align = "c", booktabs = TRUE, escape = FALSE, linesep = "",
      caption = "") %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) %>%
  row_spec(9, hline_after = T) %>%
  row_spec(18, hline_after = T) %>%
  row_spec(19, hline_after = T) 
```

```{r}
res = res[-20, ]
res$estimator <- 1:nrow(res)

# Calculate the confidence intervals
res$lower_bound <- res$PE - 1.96 * res$SE
res$upper_bound <- res$PE + 1.96 * res$SE

# Create the plot
par(mgp = c(3, 2.8, 0), mar = c(5, 5, 4, 2) + 0.1)
symbols = rep(NA, 19)
symbols[setdiff(1:19, c(1, 10:11, 13:14, 19))] = 16
symbols[c(1, 10:11, 13:14, 19)] = 17
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "", ylab = "", pch = symbols, 
     main = "", xaxt = "n", cex = 2, cex.axis = 1.8)

abline(h = 1, col = "black",lty = 1, lwd = 4)
# abline(h = res$PE[19], col = "darkgrey",lty = 3, lwd = 4)
abline(v = 9.5, col = "darkgrey",lty = 2, lwd = 4)
abline(v = 18.5, col = "darkgrey",lty = 2, lwd = 4)

# arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
#        angle = 90, code = 3, length = 0.05, lwd = 4, col = "grey40")
lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 5)
# points(res$estimator[setdiff(1:19, c(1, 10:11, 13:14, 19))],
#        res$PEsetdiff[setdiff(1:19, c(1, 10:11, 13:14, 19))], pch = 16)
# points(res$estimator[c(1, 10:11, 13:14, 19)],
#        res$PEsetdiff[c(1, 10:11, 13:14, 19)], pch = 3)
axis(1, at = res$estimator,
     labels = c(expression(hat(theta)["100"]^"100"), expression(hat(theta)["100"]^"010"), expression(hat(theta)["100"]^"001"),
                expression(hat(theta)["010"]^"100"), expression(hat(theta)["010"]^"010"), expression(hat(theta)["010"]^"001"),
                expression(hat(theta)["001"]^"100"), expression(hat(theta)["001"]^"010"), expression(hat(theta)["001"]^"001"),
                expression(hat(theta)["110"]^"110"), expression(hat(theta)["110"]^"101"), expression(hat(theta)["110"]^"011"),
                expression(hat(theta)["101"]^"110"), expression(hat(theta)["101"]^"101"), expression(hat(theta)["101"]^"011"),
                expression(hat(theta)["011"]^"110"), expression(hat(theta)["011"]^"101"), expression(hat(theta)["011"]^"011"),
                expression(hat(theta)["111"]^"111")), cex.axis = 2)
# text(c(1, 10:11, 13:14, 19),  res$upper_bound[c(1, 10:11, 13:14, 19)] + 0.1, "*", cex=2, col="black")
# rect(0.5, par("usr")[3], 9.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
# rect(9.5, par("usr")[3], 18.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
# rect(18.5, par("usr")[3], 19.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

```{r, eval=FALSE}
res = res[-8, ]
res$estimator <- 1:nrow(res)

boot.CI = t(apply(boot.res, 1, quantile, c(0.025, 0.975)))[1:7,]

# Calculate the confidence intervals
res$lower_bound <- boot.CI[, 1]
res$upper_bound <- boot.CI[, 2]

# Create the plot
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "Estimator", ylab = "Estimate", pch = 16, 
     main = "PE with 95% bootstrap CI", xaxt = "n")

lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 2)
arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 2)
axis(1, at = res$estimator, 
     labels = c(expression(hat(mu)["100"]), expression(hat(mu)["010"]), expression(hat(mu)["001"]),
                   expression(hat(mu)["110"]), expression(hat(mu)["101"]), expression(hat(mu)["011"]),
                   expression(hat(mu)["111"])))
abline(h = 1, col = "red",lty = 2, lwd = 2)
rect(0.5, par("usr")[3], 3.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
rect(3.5, par("usr")[3], 6.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
rect(6.5, par("usr")[3], 7.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

## Overall data (without IV in PS estimation)

```{r}
situation = 1
wrong.num = 1
boot = TRUE; B = 500;
```

### Code

```{r}
dat = original.dat

dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

propensity.list.0 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                              w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                              model.y = function(y) y,
                              model.x1.names = c("parent_report"),
                              model.x2.names = NULL),
                         list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                              w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                              model.y = function(y) NULL,
                              model.x1.names = c("father", "parent_report"),
                              model.x2.names = NULL),
                         list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                              w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                              model.y = function(y) y,
                              model.x1.names = c("father"),
                              model.x2.names = NULL))

propensity.list.1 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                              w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                              model.y = function(y) y,
                              model.x1.names = c("parent_report"),
                              model.x2.names = NULL),
                         list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                              w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                              model.y = function(y) NULL,
                              model.x1.names = c("father", "parent_report"),
                              model.x2.names = NULL),
                         list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                              w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                              model.y = function(y) y,
                              model.x1.names = c("father"),
                              model.x2.names = NULL))

propensity.list.list = list(propensity.list.0, propensity.list.1)
```

```{r, eval = FALSE}
auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report), as.factor(dat$father*dat$parent_report)),
                  NULL)

health.status = 0:1
subset.names = c("health0", "health1")

# effect.f = function(x, y) y/x
# delta.method = function(x, y) c(-y/x^2, 1/x)

effect.f = function(x, y) (y/(1-y))/(x/(1-x))
delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
                                ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

# effect.f = function(x, y) log((y/(1-y))/(x/(1-x)))
# delta.method = function(x, y) (x/(1-x))/(y/(1-y))*c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
#                                 ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

################################################################################
# Fit working propensity score models
################################################################################
res = matrix(NA, 8, 2)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    model.set = model.sets[, i]
    est = matrix(NA, length(health.status), 2)
    for(k in 1:length(health.status)){
      print(c(model.num, i, k))
      dat = original.dat[original.dat$health == health.status[k], ]
      N = nrow(dat)
      n = sum(dat$r)
      y = dat$y
      r = dat$r
      auxilliary = auxilliary.f(dat)
      pi.fit.list = list()
      l = 1
      for(j in model.set){
        pi.fit.list[[l]] = Wang2014.1(auxilliary = auxilliary,
                                      model.y = propensity.list.list[[k]][[j]]$model.y(y),
                                      model.x1.names = propensity.list.list[[k]][[j]]$model.x1.names,
                                      model.x2.names = propensity.list.list[[k]][[j]]$model.x2.names,
                                      w = propensity.list.list[[k]][[j]]$w,
                                      w.prime = propensity.list.list[[k]][[j]]$w.prime)
        l = l + 1
      }
      est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
      saveRDS(est.res,
              paste0(c("MHDResults/MNAR_est_", subset.names[k], "_", model.set, "_newOR1.RDS"), collapse = ""))
      est[k, ] = unlist(est.res[1:3])
    }
    effect = effect.f(est[1, 1], est[2, 1])
    Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
    se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
    res[m, ] = c(effect, se)
    m = m + 1
  }
}
################################################################################

cc1 = original.dat$health == 1 & original.dat$r == 1
cc0 = original.dat$health == 0 & original.dat$r == 1
mu.cc1 = mean(original.dat[cc1, ]$y)
se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
mu.cc0 = mean(original.dat[cc0, ]$y)
se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
res[8, ] = c(effect.f(mu.cc0, mu.cc1),
             sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
```

```{r}
auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report), as.factor(dat$father*dat$parent_report)),
                  NULL)

health.status = 0:1
subset.names = c("health0", "health1")


effect.f = function(x, y) (y/(1-y))/(x/(1-x))
delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
                                ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

res = matrix(NA, 20, 2)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    est = matrix(NA, length(health.status), 2)
    model.set0 = model.sets[, i]
    est.res0 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[1], "_", model.set0, "_newOR1.RDS"), collapse = ""))
    est[1, ] = unlist(est.res0[1:3])
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      est.res1 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[2], "_", model.set1, "_newOR1.RDS"), collapse = ""))
      est[2, ] = unlist(est.res1[1:3])
      effect = effect.f(est[1, 1], est[2, 1])
      Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
      se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
      res[m, ] = c(effect, se)
      m = m + 1
    }
  }
}
cc1 = original.dat$health == 1 & original.dat$r == 1
cc0 = original.dat$health == 0 & original.dat$r == 1
mu.cc1 = mean(original.dat[cc1, ]$y)
se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
mu.cc0 = mean(original.dat[cc0, ]$y)
se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
res[20, ] = c(effect.f(mu.cc0, mu.cc1),
             sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
res.tmp = res
```

```{r eval = FALSE}
################################################################################
# Bootstrap
################################################################################
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    model.set = model.sets[, i]
    for(k in 1:2) {
      print(c(model.num, i, k))
      dat = original.dat[original.dat$health == health.status[k], ]
      boot.res = perturb.bootstrap(propensity.list.list[[k]][model.set], auxilliary.f, dat, family, B)
      save.file = paste0(c("MHDResults/MNAR_boot_est_", subset.names[k], "_", model.set, "_newOR1.RDS"), collapse = "")
      if(file.exists(save.file)){
        boot.res = cbind(readRDS(save.file), boot.res)
        saveRDS(boot.res, save.file)
      }else{
        saveRDS(boot.res, save.file)
      }
      print("")
      print(apply(boot.res, 1, mean))
      print(apply(boot.res, 1, sd))
      gc()
    }
  }
}
################################################################################
```

```{r eval = FALSE}
################################################################################
# Bootstrap
################################################################################
if(boot){
  for(i in 1:50){
    boot.res = bootstrap.effect(propensity.list.list,
                       auxilliary.f, effect.f, original.dat, family,  B)
    save.file = "MHDResults/MNAR_est_boot_health_effect_OR2.RDS"
    if(file.exists(save.file)){
      boot.res = cbind(readRDS(save.file), boot.res)
      saveRDS(boot.res, save.file)
    }else{
      saveRDS(boot.res, save.file)
    }
    print("")
    print(apply(boot.res, 1, mean))
    print(apply(boot.res, 1, sd))
    gc()
  }
}
################################################################################
```

### Results

```{r}
# boot.res = readRDS("MHDResults/MNAR_est_boot_health_effect_OR2.RDS")
# par(mfrow = c(2, 4))
# for(i in 1:nrow(boot.res)) hist(boot.res[i, ])
```

```{r}
boot.res.se = boot.res.CI =  boot.res.se.mean = boot.res.se.CI = rep(NA, 20)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    model.set0 = model.sets[, i]
    boot.res0 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[1], "_", model.set0, "_newOR1.RDS"), collapse = ""))
    boot.res = matrix(NA, length(health.status)*2, ncol(boot.res0))
    boot.res[1, ] = boot.res0[1, ]
    boot.res[3, ] = boot.res0[2, ]
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      boot.res1 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[2], "_", model.set1, "_newOR1.RDS"), collapse = ""))
      boot.res[2, ] = boot.res1[1, ]
      boot.res[4, ] = boot.res1[2, ]
      
      # boot.effect = apply(boot.res[1:2, ], 2, function(v) effect.f(v[1], v[2]))
      # boot.res.CI[m] = paste0(c("[", paste(round(quantile(boot.effect, c(0.025, 0.975)), 4), collapse = ", "),
      #                              "]"), collapse =  "")
      # boot.res.se[m] = sd(boot.effect)
      boot.mu.hat = apply(boot.res[1:2, ], 1, function(v) mean(rm.extreme(v)))
      boot.var = apply(boot.res[1:2, ], 1, function(v) var(rm.extreme(v)))
      boot.res.se[m] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)

      # boot.se = sqrt(apply(boot.res, 2, function(v) delta.method(v[1], v[2])^2%*%c(v[3]^2, v[4]^2)))
      # boot.res.se.mean[m] = round(mean(boot.se), 4)
      # boot.res.se.CI[m] = paste0(c("[", paste(round(quantile(boot.se, c(0.025, 0.975)), 4), collapse = ", "),
      #                              "]"), collapse =  "")
      m = m + 1
    }
  }
}
boot.res[1,] = boot.res0[3, ]
boot.res[2,] = boot.res1[3, ]
# boot.effect = apply(boot.res, 2, function(v) effect.f(v[1], v[2]))
# boot.res.se[20] = sd(boot.effect)
boot.mu.hat = apply(boot.res[1:2, 1:500], 1, function(v) mean(rm.extreme(v)))
boot.var = apply(boot.res[1:2, 1:500], 1, function(v) var(rm.extreme(v)))
boot.res.se[20] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)
```

```{r}
res = res.tmp
res = cbind(res, boot.res.se)
res = as.data.frame(res)
res = cbind(round(res, 4),
            apply(cbind(res[, 1] - qnorm(0.975)*res[, 2], res[, 1] + qnorm(0.975)*res[, 2]), 1, 
                  function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))

rownames(res) = c("$\\hat{\\theta}_{100}^{100}$", "$\\hat{\\theta}_{100}^{010}$", "$\\hat{\\theta}_{100}^{001}$",
                  "$\\hat{\\theta}_{010}^{100}$", "$\\hat{\\theta}_{010}^{010}$", "$\\hat{\\theta}_{010}^{001}$",
                  "$\\hat{\\theta}_{001}^{100}$", "$\\hat{\\theta}_{001}^{010}$", "$\\hat{\\theta}_{001}^{001}$",
                  "$\\hat{\\theta}_{110}^{110}$", "$\\hat{\\theta}_{110}^{101}$", "$\\hat{\\theta}_{110}^{011}$",
                  "$\\hat{\\theta}_{101}^{110}$", "$\\hat{\\theta}_{101}^{101}$", "$\\hat{\\theta}_{101}^{011}$",
                  "$\\hat{\\theta}_{011}^{110}$", "$\\hat{\\theta}_{011}^{101}$", "$\\hat{\\theta}_{011}^{011}$",
                  "$\\hat{\\theta}_{111}^{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(res) = c("PE", "SE", "Bootstrap SE", "$95\\%$ CI")
kable(res, align = "c", booktabs = TRUE, escape = FALSE, linesep = "",
      caption = "") %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) %>%
  row_spec(9, hline_after = T) %>%
  row_spec(18, hline_after = T) %>%
  row_spec(19, hline_after = T) 
```

```{r}
res = res[-20, ]
res$estimator <- 1:nrow(res)

# Calculate the confidence intervals
res$lower_bound <- res$PE - 1.96 * res$SE
res$upper_bound <- res$PE + 1.96 * res$SE

# Create the plot
par(mgp = c(3, 2.8, 0), mar = c(5, 5, 4, 2) + 0.1)
symbols = rep(NA, 19)
symbols[setdiff(1:19, c(6, 11:12, 17:19))] = 16
symbols[c(6, 11:12, 17:19)] = 17
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "", ylab = "", pch = symbols, 
     main = "", xaxt = "n", cex = 2, cex.axis = 1.8)

abline(h = 1, col = "black",lty = 1, lwd = 4)
abline(h = res$PE[19], col = "darkgrey",lty = 3, lwd = 4)
abline(v = 9.5, col = "darkgrey",lty = 2, lwd = 4)
abline(v = 18.5, col = "darkgrey",lty = 2, lwd = 4)

arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound,
       angle = 90, code = 3, length = 0.05, lwd = 4, col = "grey40")
lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 5)
points(res$estimator[setdiff(1:19, c(6, 11:12, 17:19))],
       res$PEsetdiff[setdiff(1:19, c(6, 11:12, 17:19))], pch = 16)
points(res$estimator[c(6, 11:12, 17:19)],
       res$PEsetdiff[c(6, 11:12, 17:19)], pch = 17)
axis(1, at = res$estimator,
     labels = c(expression(hat(theta)["100"]^"100"), expression(hat(theta)["100"]^"010"), expression(hat(theta)["100"]^"001"),
                expression(hat(theta)["010"]^"100"), expression(hat(theta)["010"]^"010"), expression(hat(theta)["010"]^"001"),
                expression(hat(theta)["001"]^"100"), expression(hat(theta)["001"]^"010"), expression(hat(theta)["001"]^"001"),
                expression(hat(theta)["110"]^"110"), expression(hat(theta)["110"]^"101"), expression(hat(theta)["110"]^"011"),
                expression(hat(theta)["101"]^"110"), expression(hat(theta)["101"]^"101"), expression(hat(theta)["101"]^"011"),
                expression(hat(theta)["011"]^"110"), expression(hat(theta)["011"]^"101"), expression(hat(theta)["011"]^"011"),
                expression(hat(theta)["111"]^"111")), cex.axis = 2)
# text(c(1, 10:11, 13:14, 19),  res$upper_bound[c(1, 10:11, 13:14, 19)] + 0.1, "*", cex=2, col="black")
# rect(0.5, par("usr")[3], 9.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
# rect(9.5, par("usr")[3], 18.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
# rect(18.5, par("usr")[3], 19.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

```{r}
res = res[-20, ]
res$estimator <- 1:nrow(res)

# Calculate the confidence intervals
res$lower_bound <- res$PE - 1.96 * res$SE
res$upper_bound <- res$PE + 1.96 * res$SE

# Create the plot
par(mgp = c(3, 2.8, 0), mar = c(5, 5, 4, 2) + 0.1)
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "", ylab = "", pch = 16, 
     main = "", xaxt = "n", cex = 2, cex.axis = 1.8)

arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 4, col = "grey40")
lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 5)
points(res$estimator, res$PE, pch = 16)
axis(1, at = res$estimator,
     labels = c(expression(hat(theta)["100"]^"100"), expression(hat(theta)["100"]^"010"), expression(hat(theta)["100"]^"001"),
                expression(hat(theta)["010"]^"100"), expression(hat(theta)["010"]^"010"), expression(hat(theta)["010"]^"001"),
                expression(hat(theta)["001"]^"100"), expression(hat(theta)["001"]^"010"), expression(hat(theta)["001"]^"001"),
                expression(hat(theta)["110"]^"110"), expression(hat(theta)["110"]^"101"), expression(hat(theta)["110"]^"011"),
                expression(hat(theta)["101"]^"110"), expression(hat(theta)["101"]^"101"), expression(hat(theta)["101"]^"011"),
                expression(hat(theta)["011"]^"110"), expression(hat(theta)["011"]^"101"), expression(hat(theta)["011"]^"011"),
                expression(hat(theta)["111"]^"111")), cex.axis = 2)
text(c(6, 11:12, 17:19),  res$upper_bound[c(6, 11:12, 17:19)] + 0.1, "*", cex=2, col="black")
abline(h = 1, col = "black",lty = 1, lwd = 4)
abline(v = 9.5, col = "darkgrey",lty = 2, lwd = 4)
abline(v = 18.5, col = "darkgrey",lty = 2, lwd = 4)
# rect(0.5, par("usr")[3], 9.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
# rect(9.5, par("usr")[3], 18.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
# rect(18.5, par("usr")[3], 19.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

```{r, eval=FALSE}
res = res[-8, ]
res$estimator <- 1:nrow(res)

boot.CI = t(apply(boot.res, 1, quantile, c(0.025, 0.975)))[1:7,]

# Calculate the confidence intervals
res$lower_bound <- boot.CI[, 1]
res$upper_bound <- boot.CI[, 2]

# Create the plot
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "Estimator", ylab = "Estimate", pch = 16, 
     main = "PE with 95% bootstrap CI", xaxt = "n")

lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 2)
arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 2)
axis(1, at = res$estimator, 
     labels = c(expression(hat(mu)["100"]), expression(hat(mu)["010"]), expression(hat(mu)["001"]),
                   expression(hat(mu)["110"]), expression(hat(mu)["101"]), expression(hat(mu)["011"]),
                   expression(hat(mu)["111"])))
abline(h = 1, col = "red",lty = 2, lwd = 2)
rect(0.5, par("usr")[3], 3.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
rect(3.5, par("usr")[3], 6.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
rect(6.5, par("usr")[3], 7.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

## Overall data (Model misspecification, without IV in PS estimation)

```{r}
situation = 1
wrong.num = 1
boot = TRUE; B = 500;
```

### Code

```{r}
dat = original.dat

dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

propensity.list.0 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = NULL,
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("father", "parent_report"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL))

propensity.list.1 = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = NULL,
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL))

propensity.list.list = list(propensity.list.0, propensity.list.1)

exp.tilt.list =list(function(y, x, N) exp((N^(-1/1))*as.matrix(cbind(y))%*%rep(1, ncol(cbind(y)))),
                    function(y, x, N) exp((N^(-1/3))*as.matrix(cbind(y, x))%*%rep(-1, ncol(cbind(y, x)))),
                    function(y, x, N) exp((N^(-1/5))*as.matrix(cbind(x))%*%rep(1, ncol(cbind(x)))))
exp.tilt.model.x.names = c("parent_report", "father")
```

```{r, eval = FALSE}
auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report), as.factor(dat$father*dat$parent_report)),
                  NULL)

health.status = 0:1
subset.names = c("health0", "health1")

# effect.f = function(x, y) y/x
# delta.method = function(x, y) c(-y/x^2, 1/x)

effect.f = function(x, y) (y/(1-y))/(x/(1-x))
delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
                                ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

# effect.f = function(x, y) log((y/(1-y))/(x/(1-x)))
# delta.method = function(x, y) (x/(1-x))/(y/(1-y))*c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
#                                 ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

################################################################################
# Fit working propensity score models
################################################################################
est.res.list = list()
for(k in 1:length(health.status)){
    dat = original.dat[original.dat$health == health.status[k], ]
    N = nrow(dat)
    n = sum(dat$r)
    y = dat$y
    r = dat$r
    auxilliary = auxilliary.f(dat)
    pi.fit.list = list()
    l = 1
    for(j in 1:length(propensity.list.list[[k]])){
      pi.fit.list[[l]] = Wang2014.1(auxilliary = auxilliary,
                                    model.y = propensity.list.list[[k]][[j]]$model.y(y),
                                    model.x1.names = propensity.list.list[[k]][[j]]$model.x1.names,
                                    model.x2.names = propensity.list.list[[k]][[j]]$model.x2.names,
                                    w = propensity.list.list[[k]][[j]]$w,
                                    w.prime = propensity.list.list[[k]][[j]]$w.prime)
      l = l + 1
    }
    est.res.list[[k]] = ChuangChao2023(pi.fit.list, auxilliary, family)
}
```

```{r, eval=FALSE}
################################################################################
# Fit working propensity score models
################################################################################
res = matrix(NA, 8, 2)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    model.set = model.sets[, i]
    est = matrix(NA, length(health.status), 2)
    for(k in 1:length(health.status)){
      print(c(model.num, i, k))
      dat = original.dat[original.dat$health == health.status[k], ]
      N = nrow(dat)
      n = sum(dat$r)
      y = dat$y
      r = dat$r
      auxilliary = auxilliary.f(dat)
      mild.est.res = mild.est(est.res.list[[k]], exp.tilt.list[model.set], exp.tilt.model.x.names, 
                         auxilliary, family = "gaussian")
      saveRDS(mild.est.res,
              paste0(c("MHDResults/MNAR_est_", subset.names[k], "_", model.set, "_mild_OR3.RDS"), collapse = ""))
      est[k, ] = unlist(mild.est.res[c(1, 3)])
      print(mild.est.res$w.pi)
    }
    effect = effect.f(est[1, 1], est[2, 1])
    Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
    se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
    res[m, ] = c(effect, se)
    m = m + 1
  }
}
################################################################################

cc1 = original.dat$health == 1 & original.dat$r == 1
cc0 = original.dat$health == 0 & original.dat$r == 1
mu.cc1 = mean(original.dat[cc1, ]$y)
se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
mu.cc0 = mean(original.dat[cc0, ]$y)
se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
res[8, ] = c(effect.f(mu.cc0, mu.cc1),
             sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
```

```{r}
res = matrix(NA, 20, 2)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    est = matrix(NA, length(health.status), 2)
    model.set0 = model.sets[, i]
    est.res0 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[1], "_", model.set0, "_mild_OR3.RDS"), collapse = ""))
    est[1, ] = unlist(est.res0[c(1, 3)])
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      est.res1 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[2], "_", model.set1, "_mild_OR3.RDS"), collapse = ""))
      est[2, ] = unlist(est.res1[c(1, 3)])
      effect = effect.f(est[1, 1], est[2, 1])
      Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
      se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
      res[m, ] = c(effect, se)
      m = m + 1
    }
  }
}
cc1 = original.dat$health == 1 & original.dat$r == 1
cc0 = original.dat$health == 0 & original.dat$r == 1
mu.cc1 = mean(original.dat[cc1, ]$y)
se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
mu.cc0 = mean(original.dat[cc0, ]$y)
se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
res[20, ] = c(effect.f(mu.cc0, mu.cc1),
             sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
res.tmp = res
```

```{r eval = FALSE}
################################################################################
# Bootstrap
################################################################################
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    model.set = model.sets[, i]
    for(k in 1:2) {
      print(c(model.num, i, k))
      dat = original.dat[original.dat$health == health.status[k], ]
      boot.res = perturb.bootstrap2(est.res.list[[k]], exp.tilt.list, exp.tilt.model.x.names,
                                    auxilliary.f, dat, family, B)
      save.file = paste0(c("MHDResults/MNAR_boot_est_", subset.names[k], "_", model.set, "_mild_OR13.RDS"), collapse = "")
      if(file.exists(save.file)){
        boot.res = cbind(readRDS(save.file), boot.res)
        saveRDS(boot.res, save.file)
      }else{
        saveRDS(boot.res, save.file)
      }
      print("")
      print(apply(boot.res, 1, mean))
      print(apply(boot.res, 1, sd))
      gc()
    }
  }
}
################################################################################
```

### Results

```{r}
# boot.res = readRDS("MHDResults/MNAR_est_boot_health_effect_OR2.RDS")
# par(mfrow = c(2, 4))
# for(i in 1:nrow(boot.res)) hist(boot.res[i, ])
```

```{r}
boot.res.se = boot.res.CI =  boot.res.se.mean = boot.res.se.CI = rep(NA, 20)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    model.set0 = model.sets[, i]
    boot.res0 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[1], "_", model.set0, "_mild_OR13.RDS"), collapse = ""))
    boot.res = matrix(NA, length(health.status)*2, ncol(boot.res0))
    boot.res[1, ] = boot.res0[1, ]
    boot.res[3, ] = boot.res0[2, ]
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      boot.res1 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[2], "_", model.set1, "_mild_OR13.RDS"), collapse = ""))
      boot.res[2, ] = boot.res1[1, ]
      boot.res[4, ] = boot.res1[2, ]
      
      boot.mu.hat = apply(boot.res[1:2, ], 1, function(v) mean(rm.extreme(v)))
      boot.var = apply(boot.res[1:2, ], 1, function(v) var(rm.extreme(v)))
      boot.res.se[m] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)

      m = m + 1
    }
  }
}
boot.res[1,] = boot.res0[3, ]
boot.res[2,] = boot.res1[3, ]
boot.mu.hat = apply(boot.res[1:2, 1:1000], 1, function(v) mean(rm.extreme(v)))
boot.var = apply(boot.res[1:2, 1:1000], 1, function(v) var(rm.extreme(v)))
boot.res.se[20] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)
```

```{r}
res = res.tmp
res = cbind(res, boot.res.se)
res = as.data.frame(res)
res = cbind(round(res, 4),
            apply(cbind(res[, 1] - qnorm(0.975)*res[, 2], res[, 1] + qnorm(0.975)*res[, 2]), 1, 
                  function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))

rownames(res) = c("$\\hat{\\theta}_{100}^{100}$", "$\\hat{\\theta}_{100}^{010}$", "$\\hat{\\theta}_{100}^{001}$",
                  "$\\hat{\\theta}_{010}^{100}$", "$\\hat{\\theta}_{010}^{010}$", "$\\hat{\\theta}_{010}^{001}$",
                  "$\\hat{\\theta}_{001}^{100}$", "$\\hat{\\theta}_{001}^{010}$", "$\\hat{\\theta}_{001}^{001}$",
                  "$\\hat{\\theta}_{110}^{110}$", "$\\hat{\\theta}_{110}^{101}$", "$\\hat{\\theta}_{110}^{011}$",
                  "$\\hat{\\theta}_{101}^{110}$", "$\\hat{\\theta}_{101}^{101}$", "$\\hat{\\theta}_{101}^{011}$",
                  "$\\hat{\\theta}_{011}^{110}$", "$\\hat{\\theta}_{011}^{101}$", "$\\hat{\\theta}_{011}^{011}$",
                  "$\\hat{\\theta}_{111}^{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(res) = c("PE", "SE", "Bootstrap SE", "$95\\%$ CI")
kable(res, align = "c", booktabs = TRUE, escape = FALSE, linesep = "",
      caption = "") %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) %>%
  row_spec(9, hline_after = T) %>%
  row_spec(18, hline_after = T) %>%
  row_spec(19, hline_after = T) 
```

```{r}
res = res[-20, ]
res$estimator <- 1:nrow(res)

# Calculate the confidence intervals
res$lower_bound <- res$PE - 1.96 * res$SE
res$upper_bound <- res$PE + 1.96 * res$SE

# Create the plot
par(mgp = c(3, 2.8, 0), mar = c(5, 5, 4, 2) + 0.1)
symbols = rep(NA, 19)
symbols[setdiff(1:19, c(1, 10:11, 13:14, 19))] = 16
symbols[c(1, 10:11, 13:14, 19)] = 17
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "", ylab = "", pch = symbols, 
     main = "", xaxt = "n", cex = 2, cex.axis = 1.8)

abline(h = 1, col = "black",lty = 1, lwd = 4)
# abline(h = res$PE[19], col = "darkgrey",lty = 3, lwd = 4)
abline(v = 9.5, col = "darkgrey",lty = 2, lwd = 4)
abline(v = 18.5, col = "darkgrey",lty = 2, lwd = 4)

# arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
#        angle = 90, code = 3, length = 0.05, lwd = 4, col = "grey40")
lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 5)
# points(res$estimator[setdiff(1:19, c(1, 10:11, 13:14, 19))],
#        res$PEsetdiff[setdiff(1:19, c(1, 10:11, 13:14, 19))], pch = 16)
# points(res$estimator[c(1, 10:11, 13:14, 19)],
#        res$PEsetdiff[c(1, 10:11, 13:14, 19)], pch = 3)
axis(1, at = res$estimator,
     labels = c(expression(hat(theta)["100"]^"100"), expression(hat(theta)["100"]^"010"), expression(hat(theta)["100"]^"001"),
                expression(hat(theta)["010"]^"100"), expression(hat(theta)["010"]^"010"), expression(hat(theta)["010"]^"001"),
                expression(hat(theta)["001"]^"100"), expression(hat(theta)["001"]^"010"), expression(hat(theta)["001"]^"001"),
                expression(hat(theta)["110"]^"110"), expression(hat(theta)["110"]^"101"), expression(hat(theta)["110"]^"011"),
                expression(hat(theta)["101"]^"110"), expression(hat(theta)["101"]^"101"), expression(hat(theta)["101"]^"011"),
                expression(hat(theta)["011"]^"110"), expression(hat(theta)["011"]^"101"), expression(hat(theta)["011"]^"011"),
                expression(hat(theta)["111"]^"111")), cex.axis = 2)
# text(c(1, 10:11, 13:14, 19),  res$upper_bound[c(1, 10:11, 13:14, 19)] + 0.1, "*", cex=2, col="black")
# rect(0.5, par("usr")[3], 9.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
# rect(9.5, par("usr")[3], 18.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
# rect(18.5, par("usr")[3], 19.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

```{r, eval=FALSE}
res = res[-8, ]
res$estimator <- 1:nrow(res)

boot.CI = t(apply(boot.res, 1, quantile, c(0.025, 0.975)))[1:7,]

# Calculate the confidence intervals
res$lower_bound <- boot.CI[, 1]
res$upper_bound <- boot.CI[, 2]

# Create the plot
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "Estimator", ylab = "Estimate", pch = 16, 
     main = "PE with 95% bootstrap CI", xaxt = "n")

lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 2)
arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 2)
axis(1, at = res$estimator, 
     labels = c(expression(hat(mu)["100"]), expression(hat(mu)["010"]), expression(hat(mu)["001"]),
                   expression(hat(mu)["110"]), expression(hat(mu)["101"]), expression(hat(mu)["011"]),
                   expression(hat(mu)["111"])))
abline(h = 1, col = "red",lty = 2, lwd = 2)
rect(0.5, par("usr")[3], 3.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
rect(3.5, par("usr")[3], 6.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
rect(6.5, par("usr")[3], 7.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

## Conditional on health = 1

### Summary statistics

```{r}
summary(original.dat[original.dat$health == 1,])[,-which(colnames(original.dat) == "y")]
```

### Code

```{r}
dat = original.dat
dat = dat[dat$health == 1,]
mu.complete = mean(dat$y[dat$r == 1])
se.complete = sd(dat$y[dat$r == 1])/sqrt(n)
N = nrow(dat)
n = sum(dat$r)
subset.name = "_health1"

y = dat$y
r = dat$r
dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

propensity.list.MNAR = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = NULL,
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL))
propensity.list.MAR = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                            w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                            model.y = function(y) NULL,
                            model.x1.names = c("father"),
                            model.x2.names = NULL))
propensity.list.list = list(propensity.list.MNAR, propensity.list.MAR)
```

```{r, eval = FALSE}
auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report), as.factor(dat$father*dat$parent_report)),
                  NULL)
auxilliary = auxilliary.f(dat)

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:2){
  pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                model.y = propensity.list.MNAR[[j]]$model.y(y),
                                model.x1.names = propensity.list.MNAR[[j]]$model.x1.names,
                                model.x2.names = propensity.list.MNAR[[j]]$model.x2.names,
                                w = propensity.list.MNAR[[j]]$w, w.prime = propensity.list.MNAR[[j]]$w.prime)
}
pi.fit.list[[1]]$theta.hat
pi.fit.list[[1]]$se
pi.fit.list[[2]]$theta.hat
pi.fit.list[[2]]$se
pi.fit.list[[3]]$theta.hat
pi.fit.list[[3]]$se
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
saveRDS(est.res, paste0("MHDResults/MNAR_est", subset.name, ".RDS"))
est = unlist(est.res[1:4])
est
################################################################################

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:length(propensity.list.MAR)){
  pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                model.y = propensity.list.MAR[[j]]$model.y(y),
                                model.x1.names = propensity.list.MAR[[j]]$model.x1.names,
                                model.x2.names = propensity.list.MAR[[j]]$model.x2.names,
                                w = propensity.list.MAR[[j]]$w, w.prime = propensity.list.MAR[[j]]$w.prime)
}
pi.fit.list[[1]]$theta.hat
pi.fit.list[[1]]$se
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
saveRDS(est.res, paste0("MHDResults/MAR_est", subset.name, ".RDS"))
est = unlist(est.res[1:4])
est
################################################################################

################################################################################
# The method of Kim & Yu (2012)
################################################################################
# mu.KimYu = NA
# if(situation == 1 & wrong.num == 0){
#   gamma = alpha.true[2]
#   mu.KimYu = KimYu2012(gamma, y, u1, u2, z1, z2, r)
# }
################################################################################

################################################################################
# The method of Han (2018)
################################################################################
# est.res = readRDS("y0_y1_est.RDS")
# mu.Han = Han2018(est.res$outcome.list, est.res$pi.fit.list, family)
################################################################################

################################################################################
# Bootstrap
################################################################################
if(boot){
  for(model.num in 1:length(propensity.list.MNAR)){
    model.sets = combn(3, model.num)
    for(i in 1:ncol(model.sets)){
      model.set = model.sets[, i]
      pi.fit.list = list()
      print(c(model.num, i))
      
      propensity.list = propensity.list.MNAR[model.set]
      boot.res = bootstrap(propensity.list,
                           auxilliary.f, dat, family, situation, wrong.num,  B)
      save.file = paste0(c("MHDResults/MNAR_est_boot", subset.name, "_", model.set, ".RDS"), 
                                 collapse = "")
      if(file.exists(save.file)){
        boot.res = cbind(readRDS(save.file), boot.res)
        saveRDS(boot.res, save.file)
      }else{
        saveRDS(boot.res, save.file)
      }
      print(apply(boot.res, 1, mean))
      print(apply(boot.res, 1, sd))
      gc()
    }
  }
}
################################################################################
```

```{r eval=FALSE}
################################################################################
# Bootstrap and Jacknife SE
################################################################################
# boot.sd = apply(boot.res, 1, sd)
# jack.sd = sqrt(apply((jack.res-apply(jack.res, 1, mean))^2, 1, sum)*(1-1/N))
################################################################################

################################################################################
# Bias-corrected accelerated CI
################################################################################
Ii = (jack.res-c(est, est.allm, est.opt))*(N-1)
accelerate = (1/6)*apply(Ii^3, 1, sum)/(apply(Ii^2, 1, sum)^(3/2))
 
u = c(0.05/2, 1-0.05/2)
z0 = apply(boot.res <= c(est, est.allm, est.opt), 1, function(v) qnorm(mean(v)))
zu = qnorm(u)
BCa = matrix(NA, length(z0), 2)
for(i in 1:length(z0)){
  u.adj = pnorm(z0[i]+(z0[i]+zu)/(1-accelerate[i]*(z0[i]+zu)))
  BCa[i, ] = quantile(boot.res[i,], u.adj)
}
################################################################################
```

```{r}
situation = 1
wrong.num = 0
boot = TRUE; B = 1000;
subset.name = "health1"
```

```{r, echo=TRUE}
y = dat$y
r = dat$r
dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

outcome.formula.list = list("y~father+parent_report+father:parent_report")
propensity.list = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta),
                            w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                            model.y = function(y) NULL,
                            model.x1.names = c("father"),
                            model.x2.names  = NULL))
```

```{r, eval = FALSE}
################################################################################
# Fit working outcome models for the respondents
################################################################################
outcome.list = list()
for(k in 1:length(outcome.formula.list)){
  outcome.list[[k]] = glm(outcome.formula.list[[k]], family = family,  subset = r == 1,
                          data = dat)
}
################################################################################

print("MAR")
auxilliary = list(cbind(as.factor(dat$father), as.factor(dat$parent_report)), NULL)

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:length(propensity.list)){
  pi.fit.list[[j]] = propensity.mle(model.y = propensity.list[[j]]$model.y(y),
                                    model.x1.names = propensity.list[[j]]$model.x1.names,
                                    model.x2.names = propensity.list[[j]]$model.x2.names,
                                    w = propensity.list[[j]]$w, w.prime = propensity.list[[j]]$w.prime,
                                    dat = dat)
}
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(outcome.fit.list, pi.fit.list, auxilliary, family, dat)
saveRDS(est.res, paste0("MHDResults/MAR_est_", subset.name, ".RDS"))
est = unlist(est.res[1:13])
################################################################################

################################################################################
# Fit working outcome models for the respondents
################################################################################
outcome.list = list()
for(k in 1:length(outcome.formula.list)){
  outcome.list[[k]] = glm(outcome.formula.list[[k]], family = family,  subset = r == 1,
                          data = dat)
}
################################################################################

print("MAR.allm")
auxilliary = list(cbind(as.factor(dat$father), as.factor(dat$parent_report)), 
                                    cbind(est.res$compressed.m1, est.res$m, est.res$m0, 
                                          est.res$m*dat$parent_report, est.res$m*dat$father,
                                          est.res$m*est.res$compressed.m1, est.res$m*est.res$m0,
                                          est.res$compressed.m1*est.res$m0))

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:length(propensity.list)){
  pi.fit.list[[j]] = propensity.mle(model.y = propensity.list[[j]]$model.y(y),
                                    model.x1.names = propensity.list[[j]]$model.x1.names,
                                    model.x2.names = propensity.list[[j]]$model.x2.names,
                                    w = propensity.list[[j]]$w, w.prime = propensity.list[[j]]$w.prime,
                                    dat = dat)
}
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.allm.res = ChuangChao2023(outcome.fit.list, pi.fit.list, auxilliary, family, dat)
saveRDS(est.allm.res, paste0("MHDResults/MAR.allm_est_", subset.name, ".RDS"))
est.allm = unlist(est.allm.res[1:13])
################################################################################

################################################################################
# Fit working outcome models for the respondents
################################################################################
outcome.list = list()
for(k in 1:length(outcome.formula.list)){
  outcome.list[[k]] = glm(outcome.formula.list[[k]], family = family,  subset = r == 1,
                          data = dat)
}
################################################################################

################################################################################
# Bootstrap
################################################################################
if(boot){
  auxilliary.f1 = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report)), NULL)
  auxilliary.f2 = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report)), 
                                    cbind(est.res$compressed.m1, est.res$m, est.res$m0, 
                                          est.res$m*dat$parent_report, est.res$m*dat$father,
                                          est.res$m*est.res$compressed.m1, est.res$m*est.res$m0,
                                          est.res$compressed.m1*est.res$m0))
  auxilliary.f3 = function(dat) list(cbind(as.factor(dat$father)), cbind(est.allm.res$h.opt))
  
  boot.res = bootstrap.MAR(outcome.formula.list, propensity.list,
                            auxilliary.f1, auxilliary.f2, auxilliary.f3, 
                            dat, family, situation, wrong.num,  B)
  if(file.exists(paste0("MHDResults/MAR_est_boot_", subset.name, ".RDS"))){
    boot.res = cbind(readRDS(paste0("MHDResults/MAR_est_boot_", subset.name, ".RDS")), boot.res)
    saveRDS(boot.res, paste0("MHDResults/MAR_est_boot_", subset.name, ".RDS"))
  }else{
    saveRDS(boot.res, paste0("MHDResults/MAR_est_boot_", subset.name, ".RDS"))
  }
}
################################################################################
```

## Conditional on health = 0

### Summary statistics

```{r}
summary(original.dat[original.dat$health == 0,])[,-which(colnames(original.dat) == "y")]
```

### Code

```{r}
dat = original.dat
dat = dat[dat$health == 0,]
N = nrow(dat)
n = sum(dat$r)
mu.complete = mean(dat$y[dat$r == 1])
se.complete = sd(dat$y[dat$r == 1])/sqrt(n)
subset.name = "_health0"

y = dat$y
r = dat$r
dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

propensity.list.MNAR = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = NULL,
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("father", "parent_report"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("father"),
                                 model.x2.names = NULL))
propensity.list.MAR = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                            w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                            model.y = function(y) NULL,
                            model.x1.names = c("father"),
                            model.x2.names = NULL))
propensity.list.list = list(propensity.list.MNAR, propensity.list.MAR)
```

```{r, eval = FALSE}
auxilliary.f = function(dat) list(cbind(as.factor(dat$father), as.factor(dat$parent_report), as.factor(dat$father*dat$parent_report)),
                  NULL)
auxilliary = auxilliary.f(dat)

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:2){
  pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                model.y = propensity.list.MNAR[[j]]$model.y(y),
                                model.x1.names = propensity.list.MNAR[[j]]$model.x1.names,
                                model.x2.names = propensity.list.MNAR[[j]]$model.x2.names,
                                w = propensity.list.MNAR[[j]]$w, w.prime = propensity.list.MNAR[[j]]$w.prime)
}
pi.fit.list[[1]]$theta.hat
pi.fit.list[[1]]$se
pi.fit.list[[2]]$theta.hat
pi.fit.list[[2]]$se
pi.fit.list[[3]]$theta.hat
pi.fit.list[[3]]$se
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
saveRDS(est.res, paste0("MHDResults/MNAR_est", subset.name, ".RDS"))
est = unlist(est.res[1:4])
est
pi.mnar = est.res$pi.m%*%est.res$w.pi
################################################################################

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:length(propensity.list.MAR)){
  pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                model.y = propensity.list.MAR[[j]]$model.y(y),
                                model.x1.names = propensity.list.MAR[[j]]$model.x1.names,
                                model.x2.names = propensity.list.MAR[[j]]$model.x2.names,
                                w = propensity.list.MAR[[j]]$w, w.prime = propensity.list.MAR[[j]]$w.prime)
}
pi.fit.list[[1]]$theta.hat
pi.fit.list[[1]]$se
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
saveRDS(est.res, paste0("MHDResults/MAR_est", subset.name, ".RDS"))
est = unlist(est.res[1:4])
est
pi.mar = est.res$pi.m%*%est.res$w.pi
################################################################################

plot(cbind(pi.mnar, pi.mar))
################################################################################
# The method of Kim & Yu (2012)
################################################################################
# mu.KimYu = NA
# if(situation == 1 & wrong.num == 0){
#   gamma = alpha.true[2]
#   mu.KimYu = KimYu2012(gamma, y, u1, u2, z1, z2, r)
# }
################################################################################

################################################################################
# The method of Han (2018)
################################################################################
# est.res = readRDS("y0_y1_est.RDS")
# mu.Han = Han2018(est.res$outcome.list, est.res$pi.fit.list, family)
################################################################################

################################################################################
# Bootstrap
################################################################################
if(boot){
  for(i in 1:2){
    setting = settings[i]
    propensity.list = propensity.list.list[[i]]
    boot.res = bootstrap(propensity.list,
                        auxilliary.f, dat, family, situation, wrong.num,  B)
    if(file.exists(paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))){
      boot.res = cbind(readRDS(paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS")), boot.res)
      saveRDS(boot.res, paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))
    }else{
      saveRDS(boot.res, paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))
    }
    print(apply(boot.res, 1, mean))
    print(apply(boot.res, 1, sd))
  }
}
################################################################################
```

### Result

```{r}
subset.name = "health0"
est.res.MNAR = readRDS(paste0("MHDResults/MNAR_est_", subset.name, ".RDS"))
est.res.MAR = readRDS(paste0("MHDResults/MAR_est_", subset.name, ".RDS"))
boot.res.MNAR = readRDS(paste0("MHDResults/MNAR_est_boot_", subset.name, ".RDS"))
boot.se.MNAR = apply(boot.res.MNAR, 1, sd)
boot.res.MAR = readRDS(paste0("MHDResults/MAR_est_boot_", subset.name, ".RDS"))
boot.se.MAR = apply(boot.res.MAR, 1, sd)
```

```{r}
boxplot(boot.res.MNAR[1,])
```

```{r}
res = matrix(NA, 3, 3)
res[1, ] = c(unlist(unlist(est.res.MNAR)[1:2]), boot.se.MNAR[1])
res[2, ] = c(unlist(unlist(est.res.MAR)[1:2]), boot.se.MAR[1])
res[3, ] = c(mu.complete, se.complete, boot.se.MNAR[3])

res = cbind(round(res, 4), apply(cbind(res[, 1] - qnorm(0.975)*res[, 2], res[, 1] + qnorm(0.975)*res[, 2]), 1, 
           function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))

rownames(res) = c("$\\hat{\\mu}_\\text{MNAR}$", "$\\hat{\\mu}_\\text{MAR}$", "$\\hat{\\mu}_\\text{CC}$")
colnames(res) = c("PE", "SE", "Bootstrap.SE", "$95\\%$ CI")
kable(res, align = "c", booktabs = TRUE, escape = FALSE,
      caption = "") %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) 
```

## Conditional on father = 1

### Code

```{r}
dat = original.dat
dat = dat[dat$father == 1,]
N = nrow(dat)
n = sum(dat$r)
mu.complete = mean(dat$y[dat$r == 1])
se.complete = sd(dat$y[dat$r == 1])/sqrt(n)
subset.name = "_father1"

y = dat$y
r = dat$r
dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

propensity.list.MNAR = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("health"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("parent_report"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("parent_report", "health", "hp"),
                                 model.x2.names = NULL))
propensity.list.MAR = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                            w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                            model.y = function(y) NULL,
                            model.x1.names = c("parent_report", "father"),
                            model.x2.names = NULL))
propensity.list.list = list(propensity.list.MNAR, propensity.list.MAR)
```

```{r, eval = FALSE}
auxilliary.f = function(dat) list(cbind(as.factor(dat$health), as.factor(dat$parent_report), as.factor(dat$health*dat$parent_report)),
                  NULL)
auxilliary = auxilliary.f(dat)

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:length(propensity.list.MNAR)){
  pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                model.y = propensity.list.MNAR[[j]]$model.y(y),
                                model.x1.names = propensity.list.MNAR[[j]]$model.x1.names,
                                model.x2.names = propensity.list.MNAR[[j]]$model.x2.names,
                                w = propensity.list.MNAR[[j]]$w, w.prime = propensity.list.MNAR[[j]]$w.prime)
}
pi.fit.list[[1]]$theta.hat
pi.fit.list[[1]]$se
pi.fit.list[[2]]$theta.hat
pi.fit.list[[2]]$se
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
saveRDS(est.res, paste0("MHDResults/MNAR_est", subset.name, ".RDS"))
est = unlist(est.res[1:4])
est
################################################################################

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:length(propensity.list.MAR)){
  pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                model.y = propensity.list.MAR[[j]]$model.y(y),
                                model.x1.names = propensity.list.MAR[[j]]$model.x1.names,
                                model.x2.names = propensity.list.MAR[[j]]$model.x2.names,
                                w = propensity.list.MAR[[j]]$w, w.prime = propensity.list.MAR[[j]]$w.prime)
}
pi.fit.list[[1]]$theta.hat
pi.fit.list[[1]]$se
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
saveRDS(est.res, paste0("MHDResults/MAR_est", subset.name, ".RDS"))
est = unlist(est.res[1:4])
est
################################################################################

################################################################################
# The method of Kim & Yu (2012)
################################################################################
# mu.KimYu = NA
# if(situation == 1 & wrong.num == 0){
#   gamma = alpha.true[2]
#   mu.KimYu = KimYu2012(gamma, y, u1, u2, z1, z2, r)
# }
################################################################################

################################################################################
# The method of Han (2018)
################################################################################
# est.res = readRDS("y0_y1_est.RDS")
# mu.Han = Han2018(est.res$outcome.list, est.res$pi.fit.list, family)
################################################################################

################################################################################
# Bootstrap
################################################################################
if(boot){
  for(i in 1:2){
    setting = settings[i]
    propensity.list = propensity.list.list[[i]]
    boot.res = bootstrap(propensity.list,
                        auxilliary.f, dat, family, situation, wrong.num,  B)
    if(file.exists(paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))){
      boot.res = cbind(readRDS(paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS")), boot.res)
      saveRDS(boot.res, paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))
    }else{
      saveRDS(boot.res, paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))
    }
    print(apply(boot.res, 1, mean))
    print(apply(boot.res, 1, sd))
  }
}
################################################################################
```

## Conditional on father = 0

### Code

```{r}
dat = original.dat
dat = dat[dat$father == 0,]
N = nrow(dat)
n = sum(dat$r)
mu.complete = mean(dat$y[dat$r == 1])
se.complete = sd(dat$y[dat$r == 1])/sqrt(n)
subset.name = "_father0"

y = dat$y
r = dat$r
dat$fh = dat$father*dat$health 
dat$fp = dat$father*dat$parent_report
dat$hp = dat$health*dat$parent_report

propensity.list.MNAR = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), y, x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), y, x)%*%theta),
                                 model.y = function(y) y,
                                 model.x1.names = c("health"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("parent_report", "health"),
                                 model.x2.names = NULL),
                            list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                                 w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                                 model.y = function(y) NULL,
                                 model.x1.names = c("parent_report", "health", "hp"),
                                 model.x2.names = NULL))
propensity.list.MAR = list(list(w = function(theta, y, x, L) 1+exp(cbind(rep(1, L), x)%*%theta), 
                            w.prime = function(theta, y, x, L) exp(cbind(rep(1, L), x)%*%theta),
                            model.y = function(y) NULL,
                            model.x1.names = c("parent_report", "father"),
                            model.x2.names = NULL))
propensity.list.list = list(propensity.list.MNAR, propensity.list.MAR)
```

```{r, eval = FALSE}
auxilliary.f = function(dat) list(cbind(as.factor(dat$health), as.factor(dat$parent_report), as.factor(dat$health*dat$parent_report)),
                  NULL)
auxilliary = auxilliary.f(dat)

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:length(propensity.list.MNAR)){
  pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                model.y = propensity.list.MNAR[[j]]$model.y(y),
                                model.x1.names = propensity.list.MNAR[[j]]$model.x1.names,
                                model.x2.names = propensity.list.MNAR[[j]]$model.x2.names,
                                w = propensity.list.MNAR[[j]]$w, w.prime = propensity.list.MNAR[[j]]$w.prime)
}
pi.fit.list[[1]]$theta.hat
pi.fit.list[[1]]$se
pi.fit.list[[2]]$theta.hat
pi.fit.list[[2]]$se
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
saveRDS(est.res, paste0("MHDResults/MNAR_est", subset.name, ".RDS"))
est = unlist(est.res[1:4])
est
################################################################################

################################################################################
# Fit working propensity score models
################################################################################
pi.fit.list = list()
for(j in 1:length(propensity.list.MAR)){
  pi.fit.list[[j]] = Wang2014.1(auxilliary = auxilliary,
                                model.y = propensity.list.MAR[[j]]$model.y(y),
                                model.x1.names = propensity.list.MAR[[j]]$model.x1.names,
                                model.x2.names = propensity.list.MAR[[j]]$model.x2.names,
                                w = propensity.list.MAR[[j]]$w, w.prime = propensity.list.MAR[[j]]$w.prime)
}
pi.fit.list[[1]]$theta.hat
pi.fit.list[[1]]$se
################################################################################

################################################################################
# The method of Chuang & Chao (2023)
################################################################################
est.res = ChuangChao2023(pi.fit.list, auxilliary, family)
saveRDS(est.res, paste0("MHDResults/MAR_est", subset.name, ".RDS"))
est = unlist(est.res[1:4])
est
################################################################################

################################################################################
# The method of Kim & Yu (2012)
################################################################################
# mu.KimYu = NA
# if(situation == 1 & wrong.num == 0){
#   gamma = alpha.true[2]
#   mu.KimYu = KimYu2012(gamma, y, u1, u2, z1, z2, r)
# }
################################################################################

################################################################################
# The method of Han (2018)
################################################################################
# est.res = readRDS("y0_y1_est.RDS")
# mu.Han = Han2018(est.res$outcome.list, est.res$pi.fit.list, family)
################################################################################

################################################################################
# Bootstrap
################################################################################
if(boot){
  for(i in 1:2){
    setting = settings[i]
    propensity.list = propensity.list.list[[i]]
    boot.res = bootstrap(propensity.list,
                        auxilliary.f, dat, family, situation, wrong.num,  B)
    if(file.exists(paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))){
      boot.res = cbind(readRDS(paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS")), boot.res)
      saveRDS(boot.res, paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))
    }else{
      saveRDS(boot.res, paste0("MHDResults/", setting, "_est_boot", subset.name, ".RDS"))
    }
    print(apply(boot.res, 1, mean))
    print(apply(boot.res, 1, sd))
  }
}
################################################################################
```

## Results

```{r}
health.status = 0:1
subset.names = c("health0", "health1")
effect.f = function(x, y) (y/(1-y))/(x/(1-x))
delta.method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)), 
                                ((1/y^2)/((1/y-1)^2))/(x/(1-x)))

res = matrix(NA, 20, 2)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    est = matrix(NA, length(health.status), 2)
    model.set0 = model.sets[, i]
    est.res0 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[1], "_", model.set0, "_OR3.RDS"), collapse = ""))
    est[1, ] = unlist(est.res0[1:3])
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      est.res1 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[2], "_", model.set1, "_OR3.RDS"), collapse = ""))
      est[2, ] = unlist(est.res1[1:3])
      effect = effect.f(est[1, 1], est[2, 1])
      Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
      se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
      res[m, ] = c(effect, se)
      m = m + 1
    }
  }
}
cc1 = original.dat$health == 1 & original.dat$r == 1
cc0 = original.dat$health == 0 & original.dat$r == 1
mu.cc1 = mean(original.dat[cc1, ]$y)
se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
mu.cc0 = mean(original.dat[cc0, ]$y)
se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
res[20, ] = c(effect.f(mu.cc0, mu.cc1),
             sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
res.tmp = res

boot.res.se = boot.res.CI =  boot.res.se.mean = boot.res.se.CI = rep(NA, 20)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    model.set0 = model.sets[, i]
    boot.res0 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[1], "_", model.set0, "_OR13.RDS"), collapse = ""))
    boot.res = matrix(NA, length(health.status)*2, ncol(boot.res0))
    boot.res[1, ] = boot.res0[1, ]
    boot.res[3, ] = boot.res0[2, ]
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      boot.res1 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[2], "_", model.set1, "_OR13.RDS"), collapse = ""))
      boot.res[2, ] = boot.res1[1, ]
      boot.res[4, ] = boot.res1[2, ]
      
      # boot.effect = apply(boot.res[1:2, ], 2, function(v) effect.f(v[1], v[2]))
      # boot.res.CI[m] = paste0(c("[", paste(round(quantile(boot.effect, c(0.025, 0.975)), 4), collapse = ", "),
      #                              "]"), collapse =  "")
      # boot.res.se[m] = sd(boot.effect)
      boot.mu.hat = apply(boot.res[1:2, ], 1, function(v) mean(rm.extreme(v)))
      boot.var = apply(boot.res[1:2, ], 1, function(v) var(rm.extreme(v)))
      boot.res.se[m] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)

      # boot.se = sqrt(apply(boot.res, 2, function(v) delta.method(v[1], v[2])^2%*%c(v[3]^2, v[4]^2)))
      # boot.res.se.mean[m] = round(mean(boot.se), 4)
      # boot.res.se.CI[m] = paste0(c("[", paste(round(quantile(boot.se, c(0.025, 0.975)), 4), collapse = ", "),
      #                              "]"), collapse =  "")
      m = m + 1
    }
  }
}
boot.res[1,] = boot.res0[3, ]
boot.res[2,] = boot.res1[3, ]
# boot.effect = apply(boot.res, 2, function(v) effect.f(v[1], v[2]))
# boot.res.se[20] = sd(boot.effect)
boot.mu.hat = apply(boot.res[1:2, 1:1000], 1, function(v) mean(rm.extreme(v)))
boot.var = apply(boot.res[1:2, 1:1000], 1, function(v) var(rm.extreme(v)))
boot.res.se[20] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)

res1 = res.tmp
res1 = cbind(res1, boot.res.se)
res1 = as.data.frame(res1)
res1 = cbind(round(res1, 4),
            apply(cbind(res1[, 1] - qnorm(0.975)*res1[, 2], res1[, 1] + qnorm(0.975)*res1[, 2]), 1, 
                  function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))

rownames(res1) = c("$\\hat{\\theta}_{100}^{100}$", "$\\hat{\\theta}_{100}^{010}$", "$\\hat{\\theta}_{100}^{001}$",
                  "$\\hat{\\theta}_{010}^{100}$", "$\\hat{\\theta}_{010}^{010}$", "$\\hat{\\theta}_{010}^{001}$",
                  "$\\hat{\\theta}_{001}^{100}$", "$\\hat{\\theta}_{001}^{010}$", "$\\hat{\\theta}_{001}^{001}$",
                  "$\\hat{\\theta}_{110}^{110}$", "$\\hat{\\theta}_{110}^{101}$", "$\\hat{\\theta}_{110}^{011}$",
                  "$\\hat{\\theta}_{101}^{110}$", "$\\hat{\\theta}_{101}^{101}$", "$\\hat{\\theta}_{101}^{011}$",
                  "$\\hat{\\theta}_{011}^{110}$", "$\\hat{\\theta}_{011}^{101}$", "$\\hat{\\theta}_{011}^{011}$",
                  "$\\hat{\\theta}_{111}^{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(res1) = c("PE", "SE", "Bootstrap SE", "$95\\%$ CI")

res = matrix(NA, 20, 2)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    est = matrix(NA, length(health.status), 2)
    model.set0 = model.sets[, i]
    est.res0 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[1], "_", model.set0, "_mild_OR3.RDS"), collapse = ""))
    est[1, ] = unlist(est.res0[c(1, 3)])
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      est.res1 = readRDS(paste0(c("MHDResults/MNAR_est_", subset.names[2], "_", model.set1, "_mild_OR3.RDS"), collapse = ""))
      est[2, ] = unlist(est.res1[c(1, 3)])
      effect = effect.f(est[1, 1], est[2, 1])
      Sigma = matrix(c(est[1, 2]^2, 0, 0, est[2, 2]^2), 2,2)
      se = sqrt(delta.method(est[1, 1], est[2, 1])%*%Sigma%*%delta.method(est[1, 1], est[2, 1]))
      res[m, ] = c(effect, se)
      m = m + 1
    }
  }
}
cc1 = original.dat$health == 1 & original.dat$r == 1
cc0 = original.dat$health == 0 & original.dat$r == 1
mu.cc1 = mean(original.dat[cc1, ]$y)
se.cc1 = sd(original.dat[cc1, ]$y)/sqrt(sum(cc1))
mu.cc0 = mean(original.dat[cc0, ]$y)
se.cc0 = sd(original.dat[cc0, ]$y)/sqrt(sum(cc0))
Sigma = matrix(c(se.cc0^2, 0, 0, se.cc1^2), 2,2)
res[20, ] = c(effect.f(mu.cc0, mu.cc1),
             sqrt(delta.method(mu.cc0, mu.cc1)%*%Sigma%*%delta.method(mu.cc0, mu.cc1)))
res.tmp = res

boot.res.se = boot.res.CI =  boot.res.se.mean = boot.res.se.CI = rep(NA, 20)
m = 1
for(model.num in 1:3){
  model.sets = combn(3, model.num)
  for(i in 1:ncol(model.sets)){
    print(c(model.num, i))
    model.set0 = model.sets[, i]
    boot.res0 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[1], "_", model.set0, "_mild_OR13.RDS"), collapse = ""))
    boot.res = matrix(NA, length(health.status)*2, ncol(boot.res0))
    boot.res[1, ] = boot.res0[1, ]
    boot.res[3, ] = boot.res0[2, ]
    for(j in 1:ncol(model.sets)){
      model.set1 = model.sets[, j]
      boot.res1 = readRDS(paste0(c("MHDResults/MNAR_boot_est_", subset.names[2], "_", model.set1, "_mild_OR13.RDS"), collapse = ""))
      boot.res[2, ] = boot.res1[1, ]
      boot.res[4, ] = boot.res1[2, ]
      
      boot.mu.hat = apply(boot.res[1:2, ], 1, function(v) mean(rm.extreme(v)))
      boot.var = apply(boot.res[1:2, ], 1, function(v) var(rm.extreme(v)))
      boot.res.se[m] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)

      m = m + 1
    }
  }
}
boot.res[1,] = boot.res0[3, ]
boot.res[2,] = boot.res1[3, ]
boot.mu.hat = apply(boot.res[1:2, 1:1000], 1, function(v) mean(rm.extreme(v)))
boot.var = apply(boot.res[1:2, 1:1000], 1, function(v) var(rm.extreme(v)))
boot.res.se[20] = sqrt(delta.method(boot.mu.hat[1], boot.mu.hat[2])^2%*%boot.var)

res2 = res.tmp
res2 = cbind(res2, boot.res.se)
res2 = as.data.frame(res2)
res2 = cbind(round(res2, 4),
            apply(cbind(res2[, 1] - qnorm(0.975)*res2[, 2], res2[, 1] + qnorm(0.975)*res2[, 2]), 1, 
                  function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))

rownames(res2) = c("$\\hat{\\theta}_{100}^{100}$", "$\\hat{\\theta}_{100}^{010}$", "$\\hat{\\theta}_{100}^{001}$",
                  "$\\hat{\\theta}_{010}^{100}$", "$\\hat{\\theta}_{010}^{010}$", "$\\hat{\\theta}_{010}^{001}$",
                  "$\\hat{\\theta}_{001}^{100}$", "$\\hat{\\theta}_{001}^{010}$", "$\\hat{\\theta}_{001}^{001}$",
                  "$\\hat{\\theta}_{110}^{110}$", "$\\hat{\\theta}_{110}^{101}$", "$\\hat{\\theta}_{110}^{011}$",
                  "$\\hat{\\theta}_{101}^{110}$", "$\\hat{\\theta}_{101}^{101}$", "$\\hat{\\theta}_{101}^{011}$",
                  "$\\hat{\\theta}_{011}^{110}$", "$\\hat{\\theta}_{011}^{101}$", "$\\hat{\\theta}_{011}^{011}$",
                  "$\\hat{\\theta}_{111}^{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(res2) =c("PE", "SE", "Bootstrap SE", "$95\\%$ CI")

res = cbind(res1, res2)

rownames(res) = c("$\\hat{\\theta}_{100}^{100}$", "$\\hat{\\theta}_{100}^{010}$", "$\\hat{\\theta}_{100}^{001}$",
                  "$\\hat{\\theta}_{010}^{100}$", "$\\hat{\\theta}_{010}^{010}$", "$\\hat{\\theta}_{010}^{001}$",
                  "$\\hat{\\theta}_{001}^{100}$", "$\\hat{\\theta}_{001}^{010}$", "$\\hat{\\theta}_{001}^{001}$",
                  "$\\hat{\\theta}_{110}^{110}$", "$\\hat{\\theta}_{110}^{101}$", "$\\hat{\\theta}_{110}^{011}$",
                  "$\\hat{\\theta}_{101}^{110}$", "$\\hat{\\theta}_{101}^{101}$", "$\\hat{\\theta}_{101}^{011}$",
                  "$\\hat{\\theta}_{011}^{110}$", "$\\hat{\\theta}_{011}^{101}$", "$\\hat{\\theta}_{011}^{011}$",
                  "$\\hat{\\theta}_{111}^{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(res) = rep(c("PE", "SE", "Bootstrap SE", "$95\\%$ CI"), 2)
kable(res, align = "c", booktabs = TRUE, escape = FALSE, linesep = "",
      caption = "") %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) %>%
  row_spec(9, hline_after = T) %>%
  row_spec(18, hline_after = T) %>%
  row_spec(19, hline_after = T) %>%
  add_header_above(c(" ", "non-mild misspecification" = 4, "mild misspecification" = 4))
```

```{r}
res = res1[-20, ]
res$estimator <- 1:nrow(res)

# Calculate the confidence intervals
res$lower_bound <- res$PE - 1.96 * res$SE
res$upper_bound <- res$PE + 1.96 * res$SE

# Create the plot
par(mgp = c(3, 2.8, 0), mar = c(5, 5, 4, 2) + 0.1)
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "", ylab = "", pch = 16, 
     main = "", xaxt = "n", cex = 2, cex.axis = 1.8)

arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 4, col = "grey40")
lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 5)
points(res$estimator, res$PE, pch = 16)
axis(1, at = res$estimator,
     labels = c(expression(hat(theta)["100"]^"100"), expression(hat(theta)["100"]^"010"), expression(hat(theta)["100"]^"001"),
                expression(hat(theta)["010"]^"100"), expression(hat(theta)["010"]^"010"), expression(hat(theta)["010"]^"001"),
                expression(hat(theta)["001"]^"100"), expression(hat(theta)["001"]^"010"), expression(hat(theta)["001"]^"001"),
                expression(hat(theta)["110"]^"110"), expression(hat(theta)["110"]^"101"), expression(hat(theta)["110"]^"011"),
                expression(hat(theta)["101"]^"110"), expression(hat(theta)["101"]^"101"), expression(hat(theta)["101"]^"011"),
                expression(hat(theta)["011"]^"110"), expression(hat(theta)["011"]^"101"), expression(hat(theta)["011"]^"011"),
                expression(hat(theta)["111"]^"111")), cex.axis = 2)
text(c(6, 11:12, 17:19),  res$upper_bound[c(6, 11:12, 17:19)] + 0.1, "*", cex=2, col="black")
abline(h = 1, col = "black",lty = 1, lwd = 4)
abline(v = 9.5, col = "darkgrey",lty = 2, lwd = 4)
abline(v = 18.5, col = "darkgrey",lty = 2, lwd = 4)

res = res2[-20, ]
res$estimator <- 1:nrow(res)

# Create the plot
points(res$estimator, res$PE, pch = 16, cex = 2, col = 2)
lines(res$estimator, res$PE, lwd = 5, col = 2)
```

```{r}
subset.names = c("_health1_1", "_health1_3", "_health1_2",
                 "_health1_13", "_health1_12", "_health1_23", "_health1_123")

res = matrix(NA, 8, 3)

par(mfrow = c(2, 4))
for(i in 1:length(subset.names)){
  subset.name = subset.names[i]
  
  est.res.MNAR = readRDS(paste0("MHDResults/MNAR_est", subset.name, ".RDS"))
  print(unlist(est.res.MNAR[1:4]))
  
  boot.res.MNAR = readRDS(paste0("MHDResults/MNAR_est_boot", subset.name, ".RDS"))
  hist(boot.res.MNAR[1,], main = subset.name)
  boot.se.MNAR = apply(boot.res.MNAR, 1, sd)

  res[i, ] = c(unlist(unlist(est.res.MNAR)[1:2]), boot.se.MNAR[1])

  print("=================================")
}

res[8, ] = c(mu.complete, se.complete, boot.se.MNAR[3])
res = as.data.frame(res)

res = cbind(round(res, 4), apply(cbind(res[, 1] - qnorm(0.975)*res[, 2], res[, 1] + qnorm(0.975)*res[, 2]), 1, 
           function(v) paste0("[", round(v[1], 4) , ", ", round(v[2], 4), "]")))

rownames(res) = c("$\\hat{\\mu}_{100}$", "$\\hat{\\mu}_{010}$", "$\\hat{\\mu}_{001}$",
                  "$\\hat{\\mu}_{110}$", "$\\hat{\\mu}_{101}$", "$\\hat{\\mu}_{011}$",
                  "$\\hat{\\mu}_{111}$", "$\\hat{\\mu}_\\text{CC}$")
colnames(res) = c("PE", "SE", "Bootstrap.SE", "$95\\%$ CI")
kable(res, align = "c", booktabs = TRUE, escape = FALSE,
      caption = "") %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) 
```

```{r}
res = res[-8, ]
res$estimator <- 1:nrow(res)

# Calculate the confidence intervals
res$lower_bound <- res$PE - 1.96 * res$SE
res$upper_bound <- res$PE + 1.96 * res$SE

# Create the plot
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "Estimator", ylab = "Estimate", pch = 16, 
     main = "PE with 95% Large sample CI", xaxt = "n")

lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 2)
arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 2)
axis(1, at = res$estimator, 
     labels = c(expression(hat(mu)["100"]), expression(hat(mu)["010"]), expression(hat(mu)["001"]),
                   expression(hat(mu)["110"]), expression(hat(mu)["101"]), expression(hat(mu)["011"]),
                   expression(hat(mu)["111"])))
rect(0.5, par("usr")[3], 3.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
rect(3.5, par("usr")[3], 6.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
rect(6.5, par("usr")[3], 7.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

```{r}
res = res[-8, ]
res$estimator <- 1:nrow(res)

boot.CI = matrix(NA, 7, 2)
for(i in 1:length(subset.names)){
  subset.name = subset.names[i]
  
  boot.res.MNAR = readRDS(paste0("MHDResults/MNAR_est_boot", subset.name, ".RDS"))
  boot.CI[i, ] = quantile(boot.res.MNAR[1, ], c(0.025, 0.975))
}

# Calculate the confidence intervals
res$lower_bound <- boot.CI[, 1]
res$upper_bound <- boot.CI[, 2]

# Create the plot
plot(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound),
     xlab = "Estimator", ylab = "Estimate", pch = 16, 
     main = "PE with 95% bootstrap CI", xaxt = "n")

lines(res$estimator, res$PE, ylim = range(res$lower_bound, res$upper_bound), lwd = 2)
arrows(res$estimator, res$lower_bound, res$estimator, res$upper_bound, 
       angle = 90, code = 3, length = 0.05, lwd = 2)
axis(1, at = res$estimator, 
     labels = c(expression(hat(mu)["100"]), expression(hat(mu)["010"]), expression(hat(mu)["001"]),
                   expression(hat(mu)["110"]), expression(hat(mu)["101"]), expression(hat(mu)["011"]),
                   expression(hat(mu)["111"])))
rect(0.5, par("usr")[3], 3.5, par("usr")[4], col = rgb(1, 0, 0, 0.1), border = NA)
rect(3.5, par("usr")[3], 6.5, par("usr")[4], col = rgb(0, 0, 1, 0.1), border = NA)
rect(6.5, par("usr")[3], 7.5, par("usr")[4], col = rgb(0, 1, 0, 0.1), border = NA)
```

```{r, eval = FALSE}
subset.names = c("", "_father1", "_father0", "_health1", "_health0")
col.index = list(list(c(1, 2, 3), c(4, 5)),
                 list(c(1, 2), c(4, 5)),
                 list(c(1, 2), c(4, 5)),
                 list(c(1, 3), c(4, 5)),
                 list(c(1, 3), c(4, 5)))
res = matrix(NA, 5*3, 5)
for(i in 1:length(subset.names)){
  subset.name = subset.names[i]
  est.res.MNAR = readRDS(paste0("MHDResults/MNAR_est", subset.name, ".RDS"))
  alpha.list = show.alpha(est.res.MNAR)
  for(j in 1:length(alpha.list)){
    res[((i-1)*3+1):((i-1)*3+3), col.index[[i]][[j]]] = alpha.list[[j]][, -1]
  }
}
res[cbind(c(4, 7, 10, 13), c(3, 3, 2, 2))] = 0
res = round(res, 4)
res = cbind(rep(c("full data", "$u_1 = 1$", "$u_1 = 0$", "$u_2 = 1$", "$u_2 = 0$"), each = 3), 
            rep(c("Estimate", "SE", "p-value"), 5), res)
colnames(res) = c("Subset", "Statistic", "$\\alpha_1^1$", "$\\alpha_2^1$", "$\\alpha_3^1$", "$\\alpha_1^2$", "$\\alpha_2^2$")

res[is.na(res)] = "..."

kable(res, align = "c", booktabs = TRUE, escape = FALSE,
      caption = "") %>%
  kable_styling(full_width = F, latex_options = c("hold_position")) %>%
  collapse_rows(columns = 1) 
```


