G = function(g.matrix){
return(matrix(apply(g.matrix, 2, mean), h_dim, 1))
}
# W = function(g.matrix){
#   return(solve(t(g.matrix)%*%g.matrix/n))
# }
t_Gamma_i = function(alpha){
Gamma.arr = array(NA, dim = c(n, alpha_dim, h_dim))
for(l in 1:h_dim){
Gamma.arr[,,l] = jacobian(function(alpha) g(alpha)[, l], alpha)
}
return(Gamma.arr)
}
Gamma = function(alpha){
return(t(apply(t_Gamma_i(alpha), c(2, 3), mean)))
}
Gamma_2 = function(alpha){
return(jacobian(function(alpha) as.vector(Gamma(alpha)), alpha))
}
obj = function(alpha){
g.matrix = g(alpha)
G.hat = G(g.matrix)
value = t(G.hat)%*%G.hat
return(ifelse(is.infinite(value) || is.na(value), 10^8, value))
}
if(is.null(init)) init = rep(0, alpha_dim)
alpha_sol_path = matrix(init, alpha_dim)
conv_err = 10^8
t = 1
while (conv_err > 10^(-8) & t < 1000){
opt = optim(alpha_sol_path[,t], obj, method = "L-BFGS-B")
alpha_sol_path = cbind(alpha_sol_path, opt$par)
g.matrix = g(alpha_sol_path[,t+1]); W.hat = W(g.matrix);
obj = function(alpha){
g.matrix = g(alpha); G.hat = G(g.matrix);
value = t(G.hat)%*%W.hat%*%G.hat
return(ifelse(is.infinite(value) || is.na(value), 10^8, value))
}
conv_err = max(abs(alpha_sol_path[,t+1]-alpha_sol_path[,t]))
t = t + 1
}
alpha.hat = alpha_sol_path[, t]
fitted_values = model(x, y, alpha.hat)
Gamma.hat = Gamma(alpha.hat)
g.matrix = g(alpha.hat)
W.hat = W(g.matrix)
Gamma.hat = W.hat = K = mu_s = psi_alpha = cov.hat = se = NA
if(se.fit){
mu_s = apply(g.matrix, 2, mean)
M_n = kronecker(mu_s%*%W.hat, diag(alpha_dim))%*%Gamma_2(alpha.hat)
H_0n = -solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)
H_1n = t(Gamma.hat)%*%W.hat%*%(t(g.matrix)-mu_s)
H_2n_2 = apply(t_Gamma_i(alpha.hat), 1, function(m) (m-t(Gamma.hat))%*%W.hat%*%mu_s)
H_2n_3 = sapply(1:n, function(i) t(Gamma.hat)%*%(g.matrix[i, ]%*%t(g.matrix[i, ])-W.hat)%*%mu_s)
psi_alpha = solve(diag(alpha_dim)-H_0n%*%M_n)%*%H_0n%*%(H_1n+H_2n_2+H_2n_3)
# psi_alpha = solve(diag(alpha_dim)-H_0n%*%M_n)%*%H_0n%*%(H_1n+H_2n_2+H_2n_3)
cov.hat = var(t(psi_alpha))/n
S = var(g.matrix)
# cov.hat = solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)/N
cov.hat = solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)%*%t(Gamma.hat)%*%W.hat%*%S%*%W.hat%*%Gamma.hat%*%solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)/n
se = sqrt(diag(cov.hat))
}
results = list(coefficients = alpha.hat,
fitted.values = fitted_values,
sol.path = alpha_sol_path,
cov.hat = cov.hat,
se = se,
lower = alpha.hat-qnorm(0.975)*se,
upper = alpha.hat+qnorm(0.975)*se,
g.matrix = g.matrix,
K = solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)%*%t(Gamma.hat)%*%W.hat,
psi_alpha = psi_alpha,
model = model,
model_x_names = model_x_names,
h_x = cbind(d, h_x2))
alpha.hat
j
j=1
formula = ps_specifications$formula.list[[j]]
h_x_names = ps_specifications$h_x_names.list[[j]]
inv_link = ps_specifications$inv_link
a =  WangShaoKim2014_perturb(formula, h_x_names, inv_link, W, data = subdat, subwt, se.fit = F)
a$coefficients
j
formula = ps_specifications$formula.list[[j]]
h_x_names = ps_specifications$h_x_names.list[[j]]
inv_link = ps_specifications$inv_link
h_x_names
wt = subwt
result = parse_formula(formula)
r = as.matrix(data[result$r_names])
y = as.matrix(data[result$y_names])
x = as.matrix(data[result$x_names])
n = nrow(data)
model_x_names = colnames(x)
result = separate_variable_types(data[h_x_names])
h_x1 = result$x1
h_x2 = result$x2
is.mnar = ifelse(ncol(y) == 0, FALSE, TRUE)
alpha_dim = 1 + as.numeric(is.mnar) + ncol(x)
d = NULL
if(ncol(h_x1) > 0){
for(j in 1:ncol(h_x1)) h_x1[, j] = as.factor(h_x1[, j])
d = model.matrix(lm(rep(1, n)~., data =  h_x1))
}
discrete_dim = ncol(d)
continuous_dim = ncol(h_x2)
h_dim = discrete_dim + continuous_dim
if(continuous_dim == 0){
h_x2 = NULL
}else{
h_x2 = as.matrix(h_x2)
}
model = function(x, y, alpha){
if(!is.mnar) y = NULL
inv_link(cbind(rep(1, n), y, x)%*%alpha)
}
w = function(x, y, alpha) 1/model(x, y, alpha)
g = function(alpha){
g.matrix = matrix(NA, n, h_dim)
rw = r*w(x, y, alpha)
if(discrete_dim > 0){
for(l in 1:discrete_dim){g.matrix[, l] = d[, l]*(rw-1)}
}
if(continuous_dim > 0){
for(l in (discrete_dim+1):(discrete_dim+continuous_dim)) g.matrix[, l] = h_x2[, l-discrete_dim]*(rw-1)
}
return(wt*g.matrix)
}
G = function(g.matrix){
return(matrix(apply(g.matrix, 2, mean), h_dim, 1))
}
# W = function(g.matrix){
#   return(solve(t(g.matrix)%*%g.matrix/n))
# }
t_Gamma_i = function(alpha){
Gamma.arr = array(NA, dim = c(n, alpha_dim, h_dim))
for(l in 1:h_dim){
Gamma.arr[,,l] = jacobian(function(alpha) g(alpha)[, l], alpha)
}
return(Gamma.arr)
}
Gamma = function(alpha){
return(t(apply(t_Gamma_i(alpha), c(2, 3), mean)))
}
Gamma_2 = function(alpha){
return(jacobian(function(alpha) as.vector(Gamma(alpha)), alpha))
}
obj = function(alpha){
g.matrix = g(alpha)
G.hat = G(g.matrix)
value = t(G.hat)%*%G.hat
return(ifelse(is.infinite(value) || is.na(value), 10^8, value))
}
if(is.null(init)) init = rep(0, alpha_dim)
alpha_sol_path = matrix(init, alpha_dim)
conv_err = 10^8
t = 1
while (conv_err > 10^(-8) & t < 1000){
opt = optim(alpha_sol_path[,t], obj, method = "L-BFGS-B")
alpha_sol_path = cbind(alpha_sol_path, opt$par)
g.matrix = g(alpha_sol_path[,t+1]); W.hat = W(g.matrix);
obj = function(alpha){
g.matrix = g(alpha); G.hat = G(g.matrix);
value = t(G.hat)%*%W.hat%*%G.hat
return(ifelse(is.infinite(value) || is.na(value), 10^8, value))
}
conv_err = max(abs(alpha_sol_path[,t+1]-alpha_sol_path[,t]))
t = t + 1
}
alpha.hat = alpha_sol_path[, t]
fitted_values = model(x, y, alpha.hat)
Gamma.hat = Gamma(alpha.hat)
g.matrix = g(alpha.hat)
W.hat = W(g.matrix)
Gamma.hat = W.hat = K = mu_s = psi_alpha = cov.hat = se = NA
if(se.fit){
mu_s = apply(g.matrix, 2, mean)
M_n = kronecker(mu_s%*%W.hat, diag(alpha_dim))%*%Gamma_2(alpha.hat)
H_0n = -solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)
H_1n = t(Gamma.hat)%*%W.hat%*%(t(g.matrix)-mu_s)
H_2n_2 = apply(t_Gamma_i(alpha.hat), 1, function(m) (m-t(Gamma.hat))%*%W.hat%*%mu_s)
H_2n_3 = sapply(1:n, function(i) t(Gamma.hat)%*%(g.matrix[i, ]%*%t(g.matrix[i, ])-W.hat)%*%mu_s)
psi_alpha = solve(diag(alpha_dim)-H_0n%*%M_n)%*%H_0n%*%(H_1n+H_2n_2+H_2n_3)
# psi_alpha = solve(diag(alpha_dim)-H_0n%*%M_n)%*%H_0n%*%(H_1n+H_2n_2+H_2n_3)
cov.hat = var(t(psi_alpha))/n
S = var(g.matrix)
# cov.hat = solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)/N
cov.hat = solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)%*%t(Gamma.hat)%*%W.hat%*%S%*%W.hat%*%Gamma.hat%*%solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)/n
se = sqrt(diag(cov.hat))
}
results = list(coefficients = alpha.hat,
fitted.values = fitted_values,
sol.path = alpha_sol_path,
cov.hat = cov.hat,
se = se,
lower = alpha.hat-qnorm(0.975)*se,
upper = alpha.hat+qnorm(0.975)*se,
g.matrix = g.matrix,
K = solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)%*%t(Gamma.hat)%*%W.hat,
psi_alpha = psi_alpha,
model = model,
model_x_names = model_x_names,
h_x = cbind(d, h_x2))
alpha.hat
opt
obj(alpha.hat)
alpha.hat
obj
obj(alpha.hat)
result = parse_formula(formula)
r = as.matrix(data[result$r_names])
y = as.matrix(data[result$y_names])
x = as.matrix(data[result$x_names])
n = nrow(data)
model_x_names = colnames(x)
result = separate_variable_types(data[h_x_names])
h_x1 = result$x1
h_x2 = result$x2
is.mnar = ifelse(ncol(y) == 0, FALSE, TRUE)
alpha_dim = 1 + as.numeric(is.mnar) + ncol(x)
d = NULL
if(ncol(h_x1) > 0){
for(j in 1:ncol(h_x1)) h_x1[, j] = as.factor(h_x1[, j])
d = model.matrix(lm(rep(1, n)~., data =  h_x1))
}
discrete_dim = ncol(d)
continuous_dim = ncol(h_x2)
h_dim = discrete_dim + continuous_dim
if(continuous_dim == 0){
h_x2 = NULL
}else{
h_x2 = as.matrix(h_x2)
}
model = function(x, y, alpha){
if(!is.mnar) y = NULL
inv_link(cbind(rep(1, n), y, x)%*%alpha)
}
w = function(x, y, alpha) 1/model(x, y, alpha)
g = function(alpha){
g.matrix = matrix(NA, n, h_dim)
rw = r*w(x, y, alpha)
if(discrete_dim > 0){
for(l in 1:discrete_dim){g.matrix[, l] = d[, l]*(rw-1)}
}
if(continuous_dim > 0){
for(l in (discrete_dim+1):(discrete_dim+continuous_dim)) g.matrix[, l] = h_x2[, l-discrete_dim]*(rw-1)
}
return(wt*g.matrix)
}
G = function(g.matrix){
return(matrix(apply(g.matrix, 2, mean), h_dim, 1))
}
# W = function(g.matrix){
#   return(solve(t(g.matrix)%*%g.matrix/n))
# }
t_Gamma_i = function(alpha){
Gamma.arr = array(NA, dim = c(n, alpha_dim, h_dim))
for(l in 1:h_dim){
Gamma.arr[,,l] = jacobian(function(alpha) g(alpha)[, l], alpha)
}
return(Gamma.arr)
}
Gamma = function(alpha){
return(t(apply(t_Gamma_i(alpha), c(2, 3), mean)))
}
Gamma_2 = function(alpha){
return(jacobian(function(alpha) as.vector(Gamma(alpha)), alpha))
}
obj = function(alpha){
g.matrix = g(alpha)
G.hat = G(g.matrix)
value = t(G.hat)%*%G.hat
return(ifelse(is.infinite(value) || is.na(value), 10^8, value))
}
if(is.null(init)) init = rep(0, alpha_dim)
alpha_sol_path = matrix(init, alpha_dim)
conv_err = 10^8
t = 1
while (conv_err > 10^(-8) & t < 1000){
opt = optim(alpha_sol_path[,t], obj, method = "L-BFGS-B")
alpha_sol_path = cbind(alpha_sol_path, opt$par)
g.matrix = g(alpha_sol_path[,t+1]); W.hat = W(g.matrix);
obj = function(alpha){
g.matrix = g(alpha); G.hat = G(g.matrix);
value = t(G.hat)%*%W.hat%*%G.hat
return(ifelse(is.infinite(value) || is.na(value), 10^8, value))
}
conv_err = max(abs(alpha_sol_path[,t+1]-alpha_sol_path[,t]))
t = t + 1
}
alpha.hat = alpha_sol_path[, t]
fitted_values = model(x, y, alpha.hat)
Gamma.hat = Gamma(alpha.hat)
g.matrix = g(alpha.hat)
W.hat = W(g.matrix)
alpha.hat
obj(alpha.hat)
p.hat = se_p.hat = p_cc = se_p_cc = rep(NA, 2)
w.hat = nu.hat = c()
for(l in 1:2){
subdat = data[data$health == (l-1),]
subwt = wt[data$health == (l-1)]
ps_fit.list = list()
J = length(ps_specifications$formula.list)
for(j in 1:J){
formula = ps_specifications$formula.list[[j]]
h_x_names = ps_specifications$h_x_names.list[[j]]
inv_link = ps_specifications$inv_link
ps_fit.list[[j]] = WangShaoKim2014_perturb(formula, h_x_names, inv_link, W, data = subdat, subwt, se.fit = F)
# ps_fit.list[[j]] = WangShaoKim2014(formula, h_x_names, inv_link, W = W, data = subdat)
}
result = EBMR_IPW_perturb(h_x_names = c("father", "parent_report"), W, data = subdat, subwt, se.fit = F)
p.hat = se_p.hat = p_cc = se_p_cc = rep(NA, 2)
w.hat = nu.hat = c()
for(l in 1:2){
subdat = data[data$health == (l-1),]
subwt = wt[data$health == (l-1)]
ps_fit.list = list()
J = length(ps_specifications$formula.list)
for(j in 1:J){
formula = ps_specifications$formula.list[[j]]
h_x_names = ps_specifications$h_x_names.list[[j]]
inv_link = ps_specifications$inv_link
ps_fit.list[[j]] = WangShaoKim2014_perturb(formula, h_x_names, inv_link, W, data = subdat, subwt, se.fit = F)
# ps_fit.list[[j]] = WangShaoKim2014(formula, h_x_names, inv_link, W = W, data = subdat)
}
result = EBMR_IPW_perturb(h_x_names = c("father", "parent_report"), W, data = subdat, subwt, se.fit = F)
subwt
length(subwt)
nrow(subdat)
result = EBMR_IPW_perturb(h_x_names = c("father", "parent_report"), W, data = subdat, subwt, se.fit = F)
result$nu.hat
result$w.hat
r = as.matrix(data$r)
y = as.matrix(data$y)
n = nrow(data)
################################################################################
# Collect the propensity score models
################################################################################
J = length(ps_fit.list)
ps_model.list = lapply(ps_fit.list, function(ps_fit) ps_fit$model)
alpha.list = lapply(ps_fit.list, function(ps_fit) ps_fit$coefficients)
# alpha = unlist(lapply(ps_fit.list, function(ps_fit) ps_fit$coefficients))
# alpha_var.list = lapply(ps_fit.list, function(ps_fit) (ps_fit$se)^2)
alpha_dim = unlist(lapply(alpha.list, length))
ps.matrix = do.call(cbind, lapply(ps_fit.list, function(ps_fit) ps_fit$fitted.values))
################################################################################
################################################################################
# Ensemble step
################################################################################
ensemble_fit = ensemble_perturb(ps_fit.list, data[h_x_names], W, data, wt, init = rep(1/J, J), se.fit)
ensemble_fit$coefficients
init = rep(1/J, J)
h_x = data[h_x_names]
alpha.list = lapply(ps_fit.list, function(ps_fit) ps_fit$coefficients)
alpha.hat = unlist(alpha.list)
alpha_dim = unlist(lapply(alpha.list, length))
ps_model.list = lapply(ps_fit.list, function(ps_fit) ps_fit$model)
ps.matrix = do.call(cbind, lapply(ps_fit.list, function(ps_fit) ps_fit$fitted.values))
# Basic setup
r = as.matrix(data$r)
n = nrow(data)
# J = ncol(ps.matrix)
result = separate_variable_types(h_x)
h_x1 = result$x1
h_x2 = result$x2
d = NULL
if(ncol(h_x1) > 0){
for(j in 1:ncol(h_x1)) h_x1[, j] = as.factor(h_x1[, j])
d = model.matrix(lm(rep(1, n)~., data =  h_x1))
}
if(ncol(h_x2) == 0){
h_x2 = NULL
}else{
h_x2 = as.matrix(h_x2)
}
h_x = cbind(d, h_x2)
h_dim = ncol(h_x)
g = function(nu){
rw = r/(ps.matrix%*%nu)
g.matrix = as.vector(rw-1)*h_x
return(wt*g.matrix)
}
G = function(g.matrix){
return(matrix(apply(g.matrix, 2, mean), h_dim, 1))
}
# W = function(g.matrix){
#   return(solve(t(g.matrix)%*%g.matrix/n))
# }
t_Gamma_i = function(nu){
Gamma.arr = array(NA, dim = c(n, J, h_dim))
for(l in 1:h_dim){
Gamma.arr[,,l] = jacobian(function(nu) g(nu)[, l], nu)
}
return(Gamma.arr)
}
Gamma = function(nu){
return(t(apply(t_Gamma_i(nu), c(2, 3), mean)))
}
Gamma_2 = function(nu){
return(jacobian(function(nu) as.vector(Gamma(nu)), nu))
}
nu.hat = estimate_nu_perturb(alpha.hat, alpha_dim, ps_model.list, h_x, W, data, wt, init, se.fit)
Gamma.hat = Gamma(nu.hat)
g.matrix = g(nu.hat)
W.hat = W(g.matrix)
Gamma.hat = W.hat = K = Q = mu_s = psi_nu = cov.hat = se = NA
if(se.fit){
mu_s = apply(g.matrix, 2, mean)
M_n = kronecker(mu_s%*%W.hat, diag(J))%*%Gamma_2(nu.hat)
H_0n = -solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)
H_1n = t(Gamma.hat)%*%W.hat%*%(t(g.matrix)-mu_s)
H_2n_2 = apply(t_Gamma_i(nu.hat), 1, function(m) (m-t(Gamma.hat))%*%W.hat%*%mu_s)
H_2n_3 = sapply(1:n, function(i) t(Gamma.hat)%*%(g.matrix[i, ]%*%t(g.matrix[i, ])-W.hat)%*%mu_s)
psi_nu = solve(diag(J)-H_0n%*%M_n)%*%H_0n%*%(H_1n+H_2n_2+H_2n_3)
cov.hat = var(t(psi_nu))/n
# S = var(g.matrix)
# # cov.hat = solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)/N
# cov.hat = solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)%*%t(Gamma.hat)%*%W.hat%*%S%*%W.hat%*%Gamma.hat%*%solve(t(Gamma.hat)%*%W.hat%*%Gamma.hat)/n
se = sqrt(diag(cov.hat))
}
nu.hat
obj
opt
rm.extreme_se = function(v){
v = v[v < quantile(v, 0.98)]
return(v)
}
make_w_labels <- function(num_str) {
nums <- as.integer(strsplit(num_str, "")[[1]])
parse(text = paste0("w[", nums, "]"))
}
make_nu_labels <- function(num_str) {
nums <- as.integer(strsplit(num_str, "")[[1]])
parse(text = paste0("nu[", nums, "]"))
}
boot_result = readRDS(paste0(c("MHD_results/EBMR_IPW_perturb_bootstrap_W_identity_OR19.RDS"), collapse = ""))
rm.extreme_se = function(v){
v = v[v < quantile(v, 0.98)]
return(v)
}
make_w_labels <- function(num_str) {
nums <- as.integer(strsplit(num_str, "")[[1]])
parse(text = paste0("w[", nums, "]"))
}
make_nu_labels <- function(num_str) {
nums <- as.integer(strsplit(num_str, "")[[1]])
parse(text = paste0("nu[", nums, "]"))
}
boot_result = readRDS(paste0(c("MHD_results/EBMR_IPW_perturb_bootstrap_W_identity_OR9.RDS"), collapse = ""))
model_combinations = c("1", "2", "3", "12", "13", "23", "123")
boot_effect_se = rep(NA, 8)
# boot_se_se = rep(NA, 8)
layout_matrix = matrix(nrow = 14, ncol = 6)
for(i in 1:7){
layout_matrix[2*(i-1)+1, 1:6] = i+6*(i-1)
layout_matrix[2*(i-1)+2,] = (i+6*(i-1)+1):(i+6*(i-1)+6)
}
layout(layout_matrix, heights = rep(c(1, 5), 7))
for(k in 1:7){
par(mar = c(0, 0, 2, 0))
plot.new()
title(paste("model set:", model_combinations[k]), cex.main = 1.5)
par(mar = c(4, 2, 2, 2), pty = "s")
theta.hat = paste0("theta.hat", k)
se_theta.hat = paste0("se_theta.hat", k)
w.hat = rownames(boot_result)[grepl(paste0("w.hat", k), rownames(boot_result))]
nu.hat = rownames(boot_result)[grepl(paste0("nu.hat", k), rownames(boot_result))]
w.hat1 = w.hat[1:(length(w.hat)/2)]
w.hat2 = w.hat[(length(w.hat)/2+1):length(w.hat)]
nu.hat1 = nu.hat[1:(length(nu.hat)/2)]
nu.hat2 = nu.hat[(length(nu.hat)/2+1):length(nu.hat)]
hist(rm.extreme(boot_result[theta.hat, !is.na(boot_result[theta.hat,])]), main = expression(hat(theta)))
boot_effect_se[k] = sd(rm.extreme(boot_result[theta.hat, !is.na(boot_result[theta.hat,])]))
# hist(rm.extreme(boot_result[se_theta.hat, !is.na(boot_result[se_theta.hat,])]), main = expression(widehat("SE")(hat(theta))))
plot.new()
if(length(w.hat) == 2){
plot.new()
plot.new()
plot.new()
plot.new()
}else{
boxplot(t(boot_result[w.hat1,]), main = expression(paste(hat(bold(w)), " for ", p[0])),
names = make_w_labels(model_combinations[k]))
boxplot(t(boot_result[w.hat2,]), main = expression(paste(hat(bold(w)), " for ", p[1])),
names = make_w_labels(model_combinations[k]))
boxplot(t(boot_result[nu.hat1,]), main = expression(paste(hat(bold(nu)), " for ", p[0])),
names = make_nu_labels(model_combinations[k]))
boxplot(t(boot_result[nu.hat2,]), main = expression(paste(hat(bold(nu)), " for ", p[1])),
names = make_nu_labels(model_combinations[k]))
}
# abline(v = all_results[k, 2], col = 2, lwd = 2.5)
# boot_se_se[k] = quantile(rm.extreme_se(boot_result[3, !is.na(boot_result[3,])]), .95)
}
boot_effect_se[8] = sd(boot_result["theta_cc", !is.na(boot_result["theta_cc",])])
# boot_se_se[8] = quantile(rm.extreme_se(boot_result["se_theta_cc", !is.na(boot_result["se_theta_cc",])]), .95)
boot_effect_se
# boot_se_se
full_results = cbind(all_results, boot_effect_se)
full_results = as.data.frame(full_results)
full_results = cbind(format(full_results, digits = 3),
apply(cbind(full_results[, 1] - qnorm(0.975)*full_results[, 2],
full_results[, 1] + qnorm(0.975)*full_results[, 2]), 1,
function(v) paste0("[", format(v[1], digits = 2, nsmall = 3) , ", ", format(v[2], digits = 2, nsmall = 3), "]")))
rownames(full_results) = c("$\\hat{\\theta}_{100}$","$\\hat{\\theta}_{010}$", "$\\hat{\\theta}_{001}$",
"$\\hat{\\theta}_{110}$", "$\\hat{\\theta}_{101}$", "$\\hat{\\theta}_{011}$",
"$\\hat{\\theta}_{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(full_results) = c("PE", "SE", "Bootstrap SE", "$95\\%$ CI")
kable(full_results, align = "c", booktabs = TRUE, escape = FALSE, linesep = "",
caption = "") %>%
kable_styling(full_width = F, latex_options = c("hold_position"))
