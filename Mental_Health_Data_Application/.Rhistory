exp.tilt = function(y, x) exp(xi*as.matrix(cbind(y))%*%rep(1, ncol(cbind(y))))
exp.tilt.x.names = NULL
sa_result = EBMR_IPW_with_locally_misspecified_mode(
ps.matrix = result$ps.matrix,
perturb_ps = possibly_true_ps[k],
exp.tilt = exp.tilt,
exp.tilt.x.names = exp.tilt.x.names
)
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", 1:3, "_mild", round(xi, 3), "_OR.RDS"), collapse = "")
saveRDS(sa_result, save_file)
# print(sa_result$w.hat)
# all_estimates[k, ] = unlist(sa_result[1:2])
}
# effect = odds_ratio(all_estimates[1, 1], all_estimates[2, 1])
# Sigma = matrix(c(all_estimates[1, 2]^2, 0, 0, all_estimates[2, 2]^2), 2,2)
# se = sqrt(delta_method(all_estimates[1, 1], all_estimates[2, 1])%*%Sigma%*%delta_method(all_estimates[1, 1], all_estimates[2, 1]))
# all_results[m, ] = c(effect, se)
# m = m + 1
}
possibly_true_ps = c(3, 3)
xi.vector = seq(0, n^(-0.5), length.out = 30)
# res = matrix(NA, length(xi.vector), 2)
# m = 1
for(xi in xi.v){
all_estimates = matrix(NA, length(health), 2)
for(k in 1:length(health)){
subdat = dat[dat$health == health[k], ]
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
exp.tilt = function(y, x) exp(xi*as.matrix(cbind(y))%*%rep(1, ncol(cbind(y))))
exp.tilt.x.names = NULL
sa_result = EBMR_IPW_with_locally_misspecified_model(
ps.matrix = result$ps.matrix,
perturb_ps = possibly_true_ps[k],
exp.tilt = exp.tilt,
exp.tilt.x.names = exp.tilt.x.names
)
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", 1:3, "_mild", round(xi, 3), "_OR.RDS"), collapse = "")
saveRDS(sa_result, save_file)
# print(sa_result$w.hat)
# all_estimates[k, ] = unlist(sa_result[1:2])
}
# effect = odds_ratio(all_estimates[1, 1], all_estimates[2, 1])
# Sigma = matrix(c(all_estimates[1, 2]^2, 0, 0, all_estimates[2, 2]^2), 2,2)
# se = sqrt(delta_method(all_estimates[1, 1], all_estimates[2, 1])%*%Sigma%*%delta_method(all_estimates[1, 1], all_estimates[2, 1]))
# all_results[m, ] = c(effect, se)
# m = m + 1
}
exp.tilt = function(y, x) exp(xi*as.matrix(cbind(y))%*%rep(1, ncol(cbind(y))))
exp_tilt_x_names = NULL
possibly_true_ps.vector = c(3, 3)
xi.vector = seq(0, n^(-0.5), length.out = 30)
# res = matrix(NA, length(xi.vector), 2)
# m = 1
for(xi in xi.v){
all_estimates = matrix(NA, length(health), 2)
for(k in 1:length(health)){
subdat = dat[dat$health == health[k], ]
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
sa_result = EBMR_IPW_with_locally_misspecified_model(
ps.matrix = result$ps.matrix,
perturb_ps = possibly_true_ps.vector[k],
exp.tilt = exp.tilt,
exp_tilt_x_names = exp_tilt_x_names
)
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", 1:3, "_mild", round(xi, 3), "_OR.RDS"), collapse = "")
# saveRDS(sa_result, save_file)
# print(sa_result$w.hat)
# all_estimates[k, ] = unlist(sa_result[1:2])
}
# effect = odds_ratio(all_estimates[1, 1], all_estimates[2, 1])
# Sigma = matrix(c(all_estimates[1, 2]^2, 0, 0, all_estimates[2, 2]^2), 2,2)
# se = sqrt(delta_method(all_estimates[1, 1], all_estimates[2, 1])%*%Sigma%*%delta_method(all_estimates[1, 1], all_estimates[2, 1]))
# all_results[m, ] = c(effect, se)
# m = m + 1
}
possibly_true_ps.vector = c(3, 3)
xi.vector = seq(0, n^(-0.5), length.out = 30)
# res = matrix(NA, length(xi.vector), 2)
# m = 1
for(xi in xi.v){
all_estimates = matrix(NA, length(health), 2)
for(k in 1:length(health)){
subdat = dat[dat$health == health[k], ]
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
sa_result = EBMR_IPW_with_locally_misspecified_model(
ps.matrix = result$ps.matrix,
perturb_ps = possibly_true_ps.vector[k],
exp_tilt = exp_tilt,
exp_tilt_x_names = exp_tilt_x_names
)
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", 1:3, "_mild", round(xi, 3), "_OR.RDS"), collapse = "")
# saveRDS(sa_result, save_file)
# print(sa_result$w.hat)
# all_estimates[k, ] = unlist(sa_result[1:2])
}
# effect = odds_ratio(all_estimates[1, 1], all_estimates[2, 1])
# Sigma = matrix(c(all_estimates[1, 2]^2, 0, 0, all_estimates[2, 2]^2), 2,2)
# se = sqrt(delta_method(all_estimates[1, 1], all_estimates[2, 1])%*%Sigma%*%delta_method(all_estimates[1, 1], all_estimates[2, 1]))
# all_results[m, ] = c(effect, se)
# m = m + 1
}
roxygen2::roxygenize()
devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
roxygen2::roxygenise()
getwd()
remove.packages("EBMRalgorithm")
devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
options(knitr.kable.NA = '')
knitr::opts_chunk$set(echo = FALSE, fig.height = 10, fig.width = 16, fig.align = "center")
# devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
library(EBMRalgorithm)
library(tidyverse)
library(kableExtra)
library(ggplot2)
library(ggpubr)
original_data = read.csv("data_application.csv")
percent = original_data$Percentage
n = 2486
class_n = round(n*percent/100)
dat = matrix(NA, n, 5)
for(i in 1:nrow(original_data)){
dat[((sum(class_n[0:(i-1)]))+1):sum(class_n[1:i]),] = matrix(rep(unlist(original_data[i,]), each = class_n[i]), class_n[i], 5)
}
dat = as.data.frame(dat[, -5])
dat[dat == "Yes"] = 1
dat[dat == "No"] = 0
dat[dat == "Abnormal"] = 1
dat[dat == "Normal"] = 0
dat[dat == "Missing"] = NA
colnames(dat) = c("father", "health", "teacher_report", "parent_report")
dat$r = ifelse(is.na(dat$teacher_report), 0, 1)
dat$father = as.numeric(dat$father)
dat$health = as.numeric(dat$health)
dat$teacher_report = as.numeric(dat$teacher_report)
dat$parent_report = as.numeric(dat$parent_report)
dat$teacher_report[dat$r == 0] = -1
n = nrow(dat)
missing_rate = 1-mean(dat$r)
mu_cc = mean(dat$teacher_report[dat$r == 1])
se_cc = sd(dat$teacher_report[dat$r == 1])/sqrt(sum(r))
bootstrap = function(ps_specifications, data, B){
library(foreach)
library(doParallel)
library(doSNOW)
library(EBMRalgorithm)
n = nrow(data)
cores = detectCores()
cl = makeCluster(cores - 2) ## number of clusters
registerDoSNOW(cl)
pb = txtProgressBar(max = B, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts = list(progress = progress)
parallel_packages = c("EBMRalgorithm")
boot_result = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
tryCatch({
indices = sample(1:n, replace = TRUE)
boot_dat = data[indices,]
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = boot_dat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
estimates = unlist(result[c(1, 3)])
c(mu_ipw = estimates[1], se_ipw = estimates[2], mu_cc = mean(boot_dat$teacher_report[boot_dat$r == 1]))
}, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
}
return(boot_result)
}
bootstrap = function(ps_specifications, data, B){
library(foreach)
library(doParallel)
library(doSNOW)
library(EBMRalgorithm)
n = nrow(data)
cores = detectCores()
cl = makeCluster(cores - 2) ## number of clusters
registerDoSNOW(cl)
pb = txtProgressBar(max = B, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts = list(progress = progress)
parallel_packages = c("EBMRalgorithm")
boot_result = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
tryCatch({
indices = sample(1:n, replace = TRUE)
boot_dat = data[indices,]
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = boot_dat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
estimates = unlist(result[c(1, 3)])
c(mu_ipw = estimates[1], se_ipw = estimates[2], mu_cc = mean(boot_dat$teacher_report[boot_dat$r == 1]))
}, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
}
return(boot_result)
}
rm.extreme = function(v){
z.score = scale(v)
v = v[abs(z.score) <= 3]
print(sum(abs(z.score) > 3))
return(v)
}
show.alpha = function(est.all_results){
lapply(est.res$outcome.list, function(outcome.fit) print(round(summary(outcome.fit)$coef, 4)))
alpha.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$theta.hat)
alpha.se.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$se)
for(i in 1:length(alpha.list)){
alpha.list[[i]] = rbind(alpha.list[[i]], alpha.se.list[[i]])
p.value = (1-pnorm(abs(alpha.list[[i]][1,]/alpha.list[[i]][2,])))*2
alpha.list[[i]] = rbind(alpha.list[[i]], p.value)
rownames(alpha.list[[i]]) = c("Estimate", "SE", "p-value")
}
par(mfrow = c(1, 2))
boxplot(est.res$pi.m, ylim = c(0, 1))
boxplot(est.res$pi.m%*%est.res$w.pi, ylim = c(0, 1))
return(alpha.list)
}
#------------------------------------------------------------------------------#
# Basic Setup ----
#------------------------------------------------------------------------------#
full_ps_specifications_for_p0 = list(
formula.list = list(
r ~ o(teacher_report),
r ~ father + parent_report,
r ~ o(teacher_report) + father
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications_for_p1 = list(
formula.list = list(
r ~ o(teacher_report),
r ~ father,
r ~ o(teacher_report) + father
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications.list = list(
full_ps_specifications_for_p0,
full_ps_specifications_for_p1
)
health = 0:1
subset_names = c("health0", "health1")
odds_ratio = function(x, y) (y/(1-y))/(x/(1-x))
delta_method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)),
((1/y^2)/((1/y-1)^2))/(x/(1-x)))
boot = TRUE
B = 1000
#------------------------------------------------------------------------------#
# Estimate p_0 and p_1 using all combinations of the candidate models
#------------------------------------------------------------------------------#
for(model_num in 1:3){
model_combinations = combn(3, model_num)
for(i in 1:ncol(model_combinations)){
model_set = model_combinations[, i]
for(k in 1:length(health)){
print(c(model_num, i, k))
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
# estimates = unlist(result[1:4])
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", model_set, "_OR1.RDS"), collapse = "")
saveRDS(result, save_file)
}
}
}
#------------------------------------------------------------------------------#
# Estimate p_0 and p_1 using all combinations of the candidate models
#------------------------------------------------------------------------------#
for(model_num in 1:3){
model_combinations = combn(3, model_num)
for(i in 1:ncol(model_combinations)){
model_set = model_combinations[, i]
for(k in 1:length(health)){
print(c(model_num, i, k))
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
# estimates = unlist(result[1:4])
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", model_set, "_OR1.RDS"), collapse = "")
saveRDS(result, save_file)
}
}
}
options(knitr.kable.NA = '')
knitr::opts_chunk$set(echo = FALSE, fig.height = 10, fig.width = 16, fig.align = "center")
# devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
library(EBMRalgorithm)
library(tidyverse)
library(kableExtra)
library(ggplot2)
library(ggpubr)
source("Data_application.r")
original_data = read.csv("data_application.csv")
percent = original_data$Percentage
n = 2486
class_n = round(n*percent/100)
dat = matrix(NA, n, 5)
for(i in 1:nrow(original_data)){
dat[((sum(class_n[0:(i-1)]))+1):sum(class_n[1:i]),] = matrix(rep(unlist(original_data[i,]), each = class_n[i]), class_n[i], 5)
}
dat = as.data.frame(dat[, -5])
dat[dat == "Yes"] = 1
dat[dat == "No"] = 0
dat[dat == "Abnormal"] = 1
dat[dat == "Normal"] = 0
dat[dat == "Missing"] = NA
colnames(dat) = c("father", "health", "teacher_report", "parent_report")
dat$r = ifelse(is.na(dat$teacher_report), 0, 1)
dat$father = as.numeric(dat$father)
dat$health = as.numeric(dat$health)
dat$teacher_report = as.numeric(dat$teacher_report)
dat$parent_report = as.numeric(dat$parent_report)
dat$teacher_report[dat$r == 0] = -1
n = nrow(dat)
missing_rate = 1-mean(dat$r)
mu_cc = mean(dat$teacher_report[dat$r == 1])
se_cc = sd(dat$teacher_report[dat$r == 1])/sqrt(sum(r))
bootstrap = function(ps_specifications, data, B){
library(foreach)
library(doParallel)
library(doSNOW)
library(EBMRalgorithm)
n = nrow(data)
cores = detectCores()
cl = makeCluster(cores - 2) ## number of clusters
registerDoSNOW(cl)
pb = txtProgressBar(max = B, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts = list(progress = progress)
parallel_packages = c("EBMRalgorithm")
boot_result = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
tryCatch({
indices = sample(1:n, replace = TRUE)
boot_dat = data[indices,]
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = boot_dat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
estimates = unlist(result[c(1, 3)])
c(mu_ipw = estimates[1], se_ipw = estimates[2], mu_cc = mean(boot_dat$teacher_report[boot_dat$r == 1]))
}, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
}
return(boot_result)
}
rm.extreme = function(v){
z.score = scale(v)
v = v[abs(z.score) <= 3]
print(sum(abs(z.score) > 3))
return(v)
}
show.alpha = function(est.all_results){
lapply(est.res$outcome.list, function(outcome.fit) print(round(summary(outcome.fit)$coef, 4)))
alpha.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$theta.hat)
alpha.se.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$se)
for(i in 1:length(alpha.list)){
alpha.list[[i]] = rbind(alpha.list[[i]], alpha.se.list[[i]])
p.value = (1-pnorm(abs(alpha.list[[i]][1,]/alpha.list[[i]][2,])))*2
alpha.list[[i]] = rbind(alpha.list[[i]], p.value)
rownames(alpha.list[[i]]) = c("Estimate", "SE", "p-value")
}
par(mfrow = c(1, 2))
boxplot(est.res$pi.m, ylim = c(0, 1))
boxplot(est.res$pi.m%*%est.res$w.pi, ylim = c(0, 1))
return(alpha.list)
}
#------------------------------------------------------------------------------#
# Basic Setup ----
#------------------------------------------------------------------------------#
full_ps_specifications_for_p0 = list(
formula.list = list(
r ~ o(teacher_report),
r ~ father + parent_report,
r ~ o(teacher_report) + father
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications_for_p1 = list(
formula.list = list(
r ~ o(teacher_report),
r ~ father,
r ~ o(teacher_report) + father
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications.list = list(
full_ps_specifications_for_p0,
full_ps_specifications_for_p1
)
health = 0:1
subset_names = c("health0", "health1")
odds_ratio = function(x, y) (y/(1-y))/(x/(1-x))
delta_method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)),
((1/y^2)/((1/y-1)^2))/(x/(1-x)))
boot = TRUE
B = 1000
#------------------------------------------------------------------------------#
# Estimate p_0 and p_1 using all combinations of the candidate models
#------------------------------------------------------------------------------#
for(model_num in 1:3){
model_combinations = combn(3, model_num)
for(i in 1:ncol(model_combinations)){
model_set = model_combinations[, i]
for(k in 1:length(health)){
print(c(model_num, i, k))
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
# estimates = unlist(result[1:4])
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", model_set, "_OR1.RDS"), collapse = "")
saveRDS(result, save_file)
}
}
}
library(EBMRalgorithm)
#------------------------------------------------------------------------------#
# Estimate p_0 and p_1 using all combinations of the candidate models
#------------------------------------------------------------------------------#
for(model_num in 1:3){
model_combinations = combn(3, model_num)
for(i in 1:ncol(model_combinations)){
model_set = model_combinations[, i]
for(k in 1:length(health)){
print(c(model_num, i, k))
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
# estimates = unlist(result[1:4])
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", model_set, "_OR1.RDS"), collapse = "")
saveRDS(result, save_file)
}
}
}
