B = 500
all_results = matrix(NA, 20, 2)
k = 1
for(model_num in 1:3){
model_combinations = combn(3, model_num)
for(i in 1:ncol(model_combinations)){
print(c(model_num, i))
all_estimates = matrix(NA, length(health), 2)
model_set0 = model_combinations[, i]
result0 = readRDS(paste0(c("MHD_results/EBMR_IPW_", subset_names[1], "_", model_set0, "_OR1.RDS"), collapse = ""))
all_estimates[1, ] = unlist(result0[c(1, 3)])
for(j in 1:ncol(model_combinations)){
model_set1 = model_combinations[, j]
result1 = readRDS(paste0(c("MHD_results/EBMR_IPW_", subset_names[2], "_", model_set1, "_OR1.RDS"), collapse = ""))
all_estimates[2, ] = unlist(result1[c(1, 3)])
effect = odds_ratio(all_estimates[1, 1], all_estimates[2, 1])
Sigma = matrix(c(all_estimates[1, 2]^2, 0, 0, all_estimates[2, 2]^2), 2,2)
se = sqrt(delta_method(all_estimates[1, 1], all_estimates[2, 1])%*%Sigma%*%delta_method(all_estimates[1, 1], all_estimates[2, 1]))
all_results[k, ] = c(effect, se)
k = k + 1
}
}
}
cc1 = dat$health == 1 & dat$r == 1
cc0 = dat$health == 0 & dat$r == 1
mu_cc1 = mean(dat[cc1, ]$teacher_report)
se_cc1 = sd(dat[cc1, ]$teacher_report)/sqrt(sum(cc1))
mu_cc0 = mean(dat[cc0, ]$teacher_report)
se_cc0 = sd(dat[cc0, ]$teacher_report)/sqrt(sum(cc0))
Sigma = matrix(c(se_cc0^2, 0, 0, se_cc1^2), 2,2)
all_results[20, ] = c(odds_ratio(mu_cc0, mu_cc1),
sqrt(delta_method(mu_cc0, mu_cc1)%*%Sigma%*%delta_method(mu_cc0, mu_cc1)))
# res.tmp = res
boot_se_ipw = boot_CI =  boot_se_ipw.mean = boot_se_ipw.CI = rep(NA, 20)
k = 1
for(model_num in 1:3){
model_combinations = combn(3, model_num)
for(i in 1:ncol(model_combinations)){
print(c(model_num, i))
model_set0 = model_combinations[, i]
boot_result0 = readRDS(paste0(c("MHD_results/EBMR_IPW_bootstrap_", subset_names[1], "_", model_set0, "_OR1.RDS"), collapse = ""))
all_boot_results = matrix(NA, length(health)*2, ncol(boot_result0))
all_boot_results[1, ] = boot_result0[1, ]
all_boot_results[3, ] = boot_result0[2, ]
for(j in 1:ncol(model_combinations)){
model_set1 = model_combinations[, j]
boot_result1 = readRDS(paste0(c("MHD_results/EBMR_IPW_bootstrap_", subset_names[2], "_", model_set1, "_OR1.RDS"), collapse = ""))
all_boot_results[2, ] = boot_result1[1, ]
all_boot_results[4, ] = boot_result1[2, ]
boot.effect = apply(all_boot_results[1:2, ], 2, function(v) odds_ratio(v[1], v[2]))
# boot_CI[k] = paste0(c("[", paste(round(quantile(boot.effect, c(0.025, 0.975)), 4), collapse = ", "),
#                              "]"), collapse =  "")
boot_se_ipw[k] = sd(rm.extreme(boot.effect))
# boot_mu_ipw = apply(all_boot_results[1:2, ], 1, function(v) mean(rm.extreme(v)))
# boot_var_ipw = apply(all_boot_results[1:2, ], 1, function(v) var(rm.extreme(v)))
# # boot_mu_ipw = apply(all_boot_results[1:2, ], 1, mean)
# # boot_var_ipw = apply(all_boot_results[1:2, ], 1, mean)
# boot_se_ipw[k] = sqrt(delta_method(boot_mu_ipw[1], boot_mu_ipw[2])^2%*%boot_var_ipw)
# boot.se = sqrt(apply(boot_result, 2, function(v) delta_method(v[1], v[2])^2%*%c(v[3]^2, v[4]^2)))
# boot_se_ipw.mean[m] = round(mean(boot.se), 4)
# boot_se_ipw.CI[m] = paste0(c("[", paste(round(quantile(boot.se, c(0.025, 0.975)), 4), collapse = ", "),
#                              "]"), collapse =  "")
k = k + 1
}
}
}
all_boot_results[1,] = boot_result0[3, ]
all_boot_results[2,] = boot_result1[3, ]
boot.effect = apply(all_boot_results[1:2, ], 2, function(v) odds_ratio(v[1], v[2]))
boot_se_ipw[20] = sd(rm.extreme(boot.effect))
# boot_mu_ipw = apply(all_boot_results[1:2, ], 1, function(v) mean(rm.extreme(v)))
# boot_var_ipw = apply(all_boot_results[1:2, ], 1, function(v) var(rm.extreme(v)))
# boot_se_ipw[20] = sqrt(delta_method(boot_mu_ipw[1], boot_mu_ipw[2])^2%*%boot_var_ipw)
all_results = cbind(all_results, boot_se_ipw)
all_results = as.data.frame(all_results)
all_results = cbind(round(all_results, 3),
apply(cbind(all_results[, 1] - qnorm(0.975)*all_results[, 2],
all_results[, 1] + qnorm(0.975)*all_results[, 2]), 1,
function(v) paste0("[", round(v[1], 3) , ", ", round(v[2], 3), "]")))
rownames(all_results) = c("$\\hat{\\theta}_{100}^{100}$", "$\\hat{\\theta}_{100}^{010}$", "$\\hat{\\theta}_{100}^{001}$",
"$\\hat{\\theta}_{010}^{100}$", "$\\hat{\\theta}_{010}^{010}$", "$\\hat{\\theta}_{010}^{001}$",
"$\\hat{\\theta}_{001}^{100}$", "$\\hat{\\theta}_{001}^{010}$", "$\\hat{\\theta}_{001}^{001}$",
"$\\hat{\\theta}_{110}^{110}$", "$\\hat{\\theta}_{110}^{101}$", "$\\hat{\\theta}_{110}^{011}$",
"$\\hat{\\theta}_{101}^{110}$", "$\\hat{\\theta}_{101}^{101}$", "$\\hat{\\theta}_{101}^{011}$",
"$\\hat{\\theta}_{011}^{110}$", "$\\hat{\\theta}_{011}^{101}$", "$\\hat{\\theta}_{011}^{011}$",
"$\\hat{\\theta}_{111}^{111}$", "$\\hat{\\theta}_\\text{CC}$")
colnames(all_results) = c("PE", "SE", "Bootstrap SE", "$95\\%$ CI")
kable(all_results, align = "c", booktabs = TRUE, escape = FALSE, linesep = "",
caption = "") %>%
kable_styling(full_width = F, latex_options = c("hold_position")) %>%
row_spec(9, hline_after = T) %>%
row_spec(18, hline_after = T) %>%
row_spec(19, hline_after = T)
devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
options(knitr.kable.NA = '')
knitr::opts_chunk$set(echo = FALSE, fig.height = 10, fig.width = 16, fig.align = "center")
# devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
library(EBMRalgorithm)
library(tidyverse)
library(kableExtra)
library(ggplot2)
library(ggpubr)
original_data = read.csv("data_application.csv")
percent = original_data$Percentage
n = 2486
class_n = round(n*percent/100)
dat = matrix(NA, n, 5)
for(i in 1:nrow(original_data)){
dat[((sum(class_n[0:(i-1)]))+1):sum(class_n[1:i]),] = matrix(rep(unlist(original_data[i,]), each = class_n[i]), class_n[i], 5)
}
dat = as.data.frame(dat[, -5])
dat[dat == "Yes"] = 1
dat[dat == "No"] = 0
dat[dat == "Abnormal"] = 1
dat[dat == "Normal"] = 0
dat[dat == "Missing"] = NA
colnames(dat) = c("father", "health", "teacher_report", "parent_report")
dat$r = ifelse(is.na(dat$teacher_report), 0, 1)
dat$father = as.numeric(dat$father)
dat$health = as.numeric(dat$health)
dat$teacher_report = as.numeric(dat$teacher_report)
dat$parent_report = as.numeric(dat$parent_report)
dat$teacher_report[dat$r == 0] = -1
n = nrow(dat)
missing_rate = 1-mean(dat$r)
mu_cc = mean(dat$teacher_report[dat$r == 1])
se_cc = sd(dat$teacher_report[dat$r == 1])/sqrt(sum(r))
bootstrap = function(ps_specifications, data, B){
library(foreach)
library(doParallel)
library(doSNOW)
library(EBMRalgorithm)
n = nrow(data)
cores = detectCores()
cl = makeCluster(cores - 2) ## number of clusters
registerDoSNOW(cl)
pb = txtProgressBar(max = B, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts = list(progress = progress)
parallel_packages = c("EBMRalgorithm")
boot_result = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
tryCatch({
ebmr = EBMRAlgorithm_perturb$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = dat)
result = ebmr$EBMR_IPW_perturb(h_x_names = c("father", "parent_report"))
estimates = unlist(result[c(1, 3)])
c(mu_ipw = estimates[1], se_ipw = estimates[2], mu_cc = mean(dat$teacher_report[dat$r == 1]))
}, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
}
return(boot_result)
}
rm.extreme = function(v){
z.score = scale(v)
extreme_num = sum(abs(z.score) > 3)
print(paste(extreme_num, length(v)))
if(extreme_num == 0){
return(v)
}else{
return(v[-order(abs(z.score), decreasing = TRUE)[1:min(extreme_num, extreme_num)]])
}
}
show.alpha = function(est.all_results){
lapply(est.res$outcome.list, function(outcome.fit) print(round(summary(outcome.fit)$coef, 4)))
alpha.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$theta.hat)
alpha.se.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$se)
for(i in 1:length(alpha.list)){
alpha.list[[i]] = rbind(alpha.list[[i]], alpha.se.list[[i]])
p.value = (1-pnorm(abs(alpha.list[[i]][1,]/alpha.list[[i]][2,])))*2
alpha.list[[i]] = rbind(alpha.list[[i]], p.value)
rownames(alpha.list[[i]]) = c("Estimate", "SE", "p-value")
}
par(mfrow = c(1, 2))
boxplot(est.res$pi.m, ylim = c(0, 1))
boxplot(est.res$pi.m%*%est.res$w.pi, ylim = c(0, 1))
return(alpha.list)
}
#------------------------------------------------------------------------------#
# Basic Setup ----
#------------------------------------------------------------------------------#
full_ps_specifications_for_p0 = list(
formula.list = list(
r ~ o(teacher_report) + father,
r ~ o(teacher_report)
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications_for_p1 = list(
formula.list = list(
r ~ o(teacher_report) + father,
r ~ o(teacher_report)
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications.list = list(
full_ps_specifications_for_p0,
full_ps_specifications_for_p1
)
health = 0:1
subset_names = c("health0", "health1")
odds_ratio = function(x, y) (y/(1-y))/(x/(1-x))
delta_method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)),
((1/y^2)/((1/y-1)^2))/(x/(1-x)))
boot = TRUE
B = 500
#------------------------------------------------------------------------------#
# Basic Setup ----
#------------------------------------------------------------------------------#
full_ps_specifications_for_p0 = list(
formula.list = list(
r ~ o(teacher_report) + father,
r ~ o(teacher_report),
r ~ father
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications_for_p1 = list(
formula.list = list(
r ~ o(teacher_report) + father,
r ~ o(teacher_report),
r ~ father
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications.list = list(
full_ps_specifications_for_p0,
full_ps_specifications_for_p1
)
health = 0:1
subset_names = c("health0", "health1")
odds_ratio = function(x, y) (y/(1-y))/(x/(1-x))
delta_method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)),
((1/y^2)/((1/y-1)^2))/(x/(1-x)))
boot = TRUE
B = 500
#------------------------------------------------------------------------------#
# Estimate p_0 and p_1 using all combinations of the candidate models
#------------------------------------------------------------------------------#
for(model_num in 1:2){
model_combinations = combn(2, model_num)
for(i in 1:ncol(model_combinations)){
model_set = model_combinations[, i]
for(k in 1:length(health)){
print(c(model_num, i, k))
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
# estimates = unlist(result[1:4])
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", model_set, "_OR1.RDS"), collapse = "")
saveRDS(result, save_file)
}
}
}
#------------------------------------------------------------------------------#
# Bootstrap ----
#------------------------------------------------------------------------------#
for(model_num in 2){
model_combinations = combn(2, model_num)
for(i in 1:ncol(model_combinations)){
model_set = model_combinations[, i]
for(k in 1:2) {
print(c(model_num, i, k))
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
boot_result = bootstrap(ps_specifications, subdat, B)
save.file = paste0(c("MHD_results/EBMR_IPW_bootstrap_", subset_names[k], "_", model_set, "_OR_perturb.RDS"), collapse = "")
# if(file.exists(save.file)){
#   boot_result = cbind(readRDS(save.file), boot_result)
#   saveRDS(boot_result, save.file)
# }else{
#   saveRDS(boot_result, save.file)
# }
saveRDS(boot_result, save.file)
print("")
print(apply(boot_result, 1, mean))
print(apply(boot_result, 1, sd))
gc()
}
}
}
B
subdat
dat = subdat
ebmr = EBMRAlgorithm_perturb$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = dat)
devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
options(knitr.kable.NA = '')
knitr::opts_chunk$set(echo = FALSE, fig.height = 10, fig.width = 16, fig.align = "center")
# devtools::install_github("LukeChuang890212/EBMR_Methods_Reproducibility_Materials/EBMRalgorithm")
library(EBMRalgorithm)
library(tidyverse)
library(kableExtra)
library(ggplot2)
library(ggpubr)
original_data = read.csv("data_application.csv")
percent = original_data$Percentage
n = 2486
class_n = round(n*percent/100)
dat = matrix(NA, n, 5)
for(i in 1:nrow(original_data)){
dat[((sum(class_n[0:(i-1)]))+1):sum(class_n[1:i]),] = matrix(rep(unlist(original_data[i,]), each = class_n[i]), class_n[i], 5)
}
dat = as.data.frame(dat[, -5])
dat[dat == "Yes"] = 1
dat[dat == "No"] = 0
dat[dat == "Abnormal"] = 1
dat[dat == "Normal"] = 0
dat[dat == "Missing"] = NA
colnames(dat) = c("father", "health", "teacher_report", "parent_report")
dat$r = ifelse(is.na(dat$teacher_report), 0, 1)
dat$father = as.numeric(dat$father)
dat$health = as.numeric(dat$health)
dat$teacher_report = as.numeric(dat$teacher_report)
dat$parent_report = as.numeric(dat$parent_report)
dat$teacher_report[dat$r == 0] = -1
n = nrow(dat)
missing_rate = 1-mean(dat$r)
mu_cc = mean(dat$teacher_report[dat$r == 1])
se_cc = sd(dat$teacher_report[dat$r == 1])/sqrt(sum(r))
bootstrap = function(ps_specifications, data, B){
library(foreach)
library(doParallel)
library(doSNOW)
library(EBMRalgorithm)
n = nrow(data)
cores = detectCores()
cl = makeCluster(cores - 2) ## number of clusters
registerDoSNOW(cl)
pb = txtProgressBar(max = B, style = 3)
progress <- function(n) setTxtProgressBar(pb, n)
opts = list(progress = progress)
parallel_packages = c("EBMRalgorithm")
boot_result = foreach(i= 1:B, .combine = 'cbind', .options.snow = opts, .packages = parallel_packages) %dopar% {
tryCatch({
ebmr = EBMRAlgorithm_perturb$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = data)
result = ebmr$EBMR_IPW_perturb(h_x_names = c("father", "parent_report"))
estimates = unlist(result[c(1, 3)])
c(mu_ipw = estimates[1], se_ipw = estimates[2], mu_cc = mean(data$teacher_report[data$r == 1]))
}, error = function(e){print("ERROR :",conditionMessage(e), "\n")})
}
return(boot_result)
}
rm.extreme = function(v){
z.score = scale(v)
extreme_num = sum(abs(z.score) > 3)
print(paste(extreme_num, length(v)))
if(extreme_num == 0){
return(v)
}else{
return(v[-order(abs(z.score), decreasing = TRUE)[1:min(extreme_num, extreme_num)]])
}
}
show.alpha = function(est.all_results){
lapply(est.res$outcome.list, function(outcome.fit) print(round(summary(outcome.fit)$coef, 4)))
alpha.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$theta.hat)
alpha.se.list = lapply(est.res$pi.fit.list, function(pi.fit) pi.fit$se)
for(i in 1:length(alpha.list)){
alpha.list[[i]] = rbind(alpha.list[[i]], alpha.se.list[[i]])
p.value = (1-pnorm(abs(alpha.list[[i]][1,]/alpha.list[[i]][2,])))*2
alpha.list[[i]] = rbind(alpha.list[[i]], p.value)
rownames(alpha.list[[i]]) = c("Estimate", "SE", "p-value")
}
par(mfrow = c(1, 2))
boxplot(est.res$pi.m, ylim = c(0, 1))
boxplot(est.res$pi.m%*%est.res$w.pi, ylim = c(0, 1))
return(alpha.list)
}
#------------------------------------------------------------------------------#
# Basic Setup ----
#------------------------------------------------------------------------------#
full_ps_specifications_for_p0 = list(
formula.list = list(
r ~ o(teacher_report) + father,
r ~ o(teacher_report),
r ~ father
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications_for_p1 = list(
formula.list = list(
r ~ o(teacher_report) + father,
r ~ o(teacher_report),
r ~ father
),
h_x_names.list = list(
c("father", "parent_report"),
c("father", "parent_report"),
c("father", "parent_report")
),
inv_link = function(eta) 1/(1+exp(eta))
)
full_ps_specifications.list = list(
full_ps_specifications_for_p0,
full_ps_specifications_for_p1
)
health = 0:1
subset_names = c("health0", "health1")
odds_ratio = function(x, y) (y/(1-y))/(x/(1-x))
delta_method = function(x, y) c(-(y/(1-y))/((x/(1-x))^2)*((1/x^2)/((1/x-1)^2)),
((1/y^2)/((1/y-1)^2))/(x/(1-x)))
boot = TRUE
B = 500
#------------------------------------------------------------------------------#
# Estimate p_0 and p_1 using all combinations of the candidate models
#------------------------------------------------------------------------------#
for(model_num in 1:2){
model_combinations = combn(2, model_num)
for(i in 1:ncol(model_combinations)){
model_set = model_combinations[, i]
for(k in 1:length(health)){
print(c(model_num, i, k))
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = subdat)
result = ebmr$EBMR_IPW(h_x_names = c("father", "parent_report"))
# estimates = unlist(result[1:4])
save_file = paste0(c("MHD_results/EBMR_IPW_", subset_names[k], "_", model_set, "_OR1.RDS"), collapse = "")
saveRDS(result, save_file)
}
}
}
#------------------------------------------------------------------------------#
# Bootstrap ----
#------------------------------------------------------------------------------#
for(model_num in 2){
model_combinations = combn(2, model_num)
for(i in 1:ncol(model_combinations)){
model_set = model_combinations[, i]
for(k in 1:2) {
print(c(model_num, i, k))
subdat = dat[dat$health == health[k], ]
full_ps_specifications = full_ps_specifications.list[[k]]
ps_specifications <- list(
formula.list = full_ps_specifications$formula.list[model_set],
h_x_names.list = full_ps_specifications$h_x_names.list[model_set],
inv_link = full_ps_specifications$inv_link
)
boot_result = bootstrap(ps_specifications, subdat, B)
save.file = paste0(c("MHD_results/EBMR_IPW_bootstrap_", subset_names[k], "_", model_set, "_OR_perturb.RDS"), collapse = "")
# if(file.exists(save.file)){
#   boot_result = cbind(readRDS(save.file), boot_result)
#   saveRDS(boot_result, save.file)
# }else{
#   saveRDS(boot_result, save.file)
# }
saveRDS(boot_result, save.file)
print("")
print(apply(boot_result, 1, mean))
print(apply(boot_result, 1, sd))
gc()
}
}
}
data = subdat
ebmr = EBMRAlgorithm_perturb$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = data)
EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = data)
ebmr = EBMRAlgorithm$new(y_names = "teacher_report",
ps_specifications = ps_specifications,
data = data)
